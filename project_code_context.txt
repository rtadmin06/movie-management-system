Project Source: C:\Users\杨礼煜同学\Desktop\movie-management-system\movie-management-system
==================================================

FILE_PATH: 111.py
-------------------- START --------------------
import os

def merge_project_files(source_dir, output_file):
    # 1. 定义需要忽略的文件夹
    IGNORE_DIRS = {
        'node_modules', 
        '.git', 
        '.idea', 
        '.vscode', 
        'dist', 
        'build', 
        'coverage',
        '__pycache__'
    }

    # 2. 定义需要忽略的具体文件名
    IGNORE_FILES = {
        'package-lock.json', 
        'yarn.lock', 
        'pnpm-lock.yaml',
        '.DS_Store',
        'movies.json',
        os.path.basename(output_file) # 防止把自己也写进去
    }

    # 3. 定义不仅不需要读取，而且通常是二进制的图片/文件后缀（避免乱码）
    BINARY_EXTENSIONS = {
        '.png', '.jpg', '.jpeg', '.gif', '.ico', '.svg', 
        '.woff', '.woff2', '.ttf', '.eot', 
        '.mp4', '.mp3', '.exe', '.dll', '.pyc'
    }

    # 用于统计
    file_count = 0
    
    try:
        with open(output_file, 'w', encoding='utf-8') as outfile:
            # 写入文件头信息
            outfile.write(f"Project Source: {source_dir}\n")
            outfile.write("=" * 50 + "\n\n")

            # 遍历目录
            for root, dirs, files in os.walk(source_dir):
                # 修改 dirs 列表，以便在遍历时跳过忽略的文件夹
                # 注意：必须原地修改 dirs[:]
                dirs[:] = [d for d in dirs if d not in IGNORE_DIRS]

                for file in files:
                    file_path = os.path.join(root, file)
                    file_name = file
                    file_ext = os.path.splitext(file)[1].lower()

                    # 检查文件名是否在忽略列表中
                    if file_name in IGNORE_FILES:
                        continue
                    
                    # 检查是否是二进制/图片文件
                    if file_ext in BINARY_EXTENSIONS:
                        continue

                    # 尝试读取并写入
                    try:
                        # 构造相对路径，方便阅读
                        relative_path = os.path.relpath(file_path, source_dir)
                        
                        outfile.write(f"FILE_PATH: {relative_path}\n")
                        outfile.write("-" * 20 + " START " + "-" * 20 + "\n")
                        
                        with open(file_path, 'r', encoding='utf-8') as infile:
                            content = infile.read()
                            outfile.write(content)
                            
                        outfile.write("\n" + "-" * 20 + "  END  " + "-" * 20 + "\n")
                        outfile.write("\n\n")
                        
                        print(f"已处理: {relative_path}")
                        file_count += 1

                    except UnicodeDecodeError:
                        print(f"[跳过] 无法以UTF-8解码文件 (可能是二进制文件): {relative_path}")
                    except Exception as e:
                        print(f"[错误] 读取文件出错 {relative_path}: {e}")

        print(f"\n完成！共合并了 {file_count} 个文件。")
        print(f"结果已保存至: {os.path.abspath(output_file)}")

    except Exception as e:
        print(f"程序运行出错: {e}")

if __name__ == '__main__':
    # 配置路径
    # 注意：Windows路径建议在引号前加 r，防止转义字符问题
    SOURCE_DIRECTORY = r"C:\Users\杨礼煜同学\Desktop\movie-management-system\movie-management-system"
    OUTPUT_FILENAME = "project_code_context.txt"

    merge_project_files(SOURCE_DIRECTORY, OUTPUT_FILENAME)
--------------------  END  --------------------


FILE_PATH: scraper.ts
-------------------- START --------------------
import puppeteer, { Browser, Page } from 'puppeteer';
import * as fs from 'fs';
import * as path from 'path';
import * as https from 'https';
import { Movie, ScraperConfig } from './types';

const config: ScraperConfig = {
  baseUrl: 'https://movie.douban.com/top250',
  totalPages: 10,
  itemsPerPage: 25,
  outputDir: path.join(__dirname, '../data'),
  imagesDir: path.join(__dirname, '../data/images'),
  delayBetweenRequests: 2000
};

// 创建必要的目录
function ensureDirectoryExists(dir: string): void {
  if (!fs.existsSync(dir)) {
    fs.mkdirSync(dir, { recursive: true });
    console.log(`Created directory: ${dir}`);
  }
}

// 下载图片
function downloadImage(url: string, filepath: string): Promise<void> {
  return new Promise((resolve, reject) => {
    const file = fs.createWriteStream(filepath);
    https.get(url, (response) => {
      response.pipe(file);
      file.on('finish', () => {
        file.close();
        resolve();
      });
    }).on('error', (err) => {
      fs.unlink(filepath, () => {});
      reject(err);
    });
  });
}

// 延迟函数
function delay(ms: number): Promise<void> {
  return new Promise(resolve => setTimeout(resolve, ms));
}

// 提取电影详细信息
async function scrapeMovieDetails(page: Page, movieUrl: string): Promise<Partial<Movie>> {
  try {
    await page.goto(movieUrl, { waitUntil: 'networkidle2', timeout: 30000 });
    await delay(1000);

    const details = await page.evaluate(() => {
      const info: any = {};
      
      // 获取基本信息
      const infoDiv = document.querySelector('#info');
      if (infoDiv) {
        const text = infoDiv.textContent || '';
        
        // 导演
        const directorMatch = text.match(/导演:(.*?)(?:编剧|主演|类型|$)/s);
        if (directorMatch) {
          info.directors = directorMatch[1].trim().split('/').map((d: string) => d.trim()).filter((d: string) => d);
        }
        
        // 主演
        const actorMatch = text.match(/主演:(.*?)(?:类型|制片国家|$)/s);
        if (actorMatch) {
          info.actors = actorMatch[1].trim().split('/').map((a: string) => a.trim()).filter((a: string) => a).slice(0, 5);
        }
        
        // 类型
        const genreMatch = text.match(/类型:(.*?)(?:制片国家|语言|$)/s);
        if (genreMatch) {
          info.genres = genreMatch[1].trim().split('/').map((g: string) => g.trim()).filter((g: string) => g);
        }
        
        // 国家
        const countryMatch = text.match(/制片国家\/地区:(.*?)(?:语言|上映日期|$)/s);
        if (countryMatch) {
          info.countries = countryMatch[1].trim().split('/').map((c: string) => c.trim()).filter((c: string) => c);
        }
        
        // 语言
        const languageMatch = text.match(/语言:(.*?)(?:上映日期|片长|$)/s);
        if (languageMatch) {
          info.language = languageMatch[1].trim();
        }
        
        // 上映日期
        const dateMatch = text.match(/上映日期:(.*?)(?:片长|又名|$)/s);
        if (dateMatch) {
          info.releaseDate = dateMatch[1].trim().split('/')[0].trim();
        }
        
        // 片长
        const durationMatch = text.match(/片长:(.*?)(?:又名|IMDb|$)/s);
        if (durationMatch) {
          info.duration = durationMatch[1].trim();
        }
        
        // 又名
        const akaMatch = text.match(/又名:(.*?)$/s);
        if (akaMatch) {
          info.aka = akaMatch[1].trim().split('/').map((a: string) => a.trim()).filter((a: string) => a);
        }
        
        // IMDb
        const imdbMatch = text.match(/IMDb:(.*?)$/s);
        if (imdbMatch) {
          info.imdbId = imdbMatch[1].trim();
        }
      }
      
      // 获取简介
      const summarySpan = document.querySelector('span[property="v:summary"]');
      if (summarySpan) {
        info.summary = summarySpan.textContent?.trim() || '';
      }
      
      return info;
    });

    return details;
  } catch (error) {
    console.error(`Error scraping details for ${movieUrl}:`, error);
    return {};
  }
}

// 爬取单页电影列表
async function scrapePage(browser: Browser, pageNum: number): Promise<Movie[]> {
  const page = await browser.newPage();
  const url = `${config.baseUrl}?start=${pageNum * config.itemsPerPage}`;
  
  console.log(`Scraping page ${pageNum + 1}...`);
  console.log(`URL: ${url}`);
  
  try {
    await page.goto(url, { waitUntil: 'networkidle2', timeout: 30000 });
    await delay(1000);

    const movies = await page.evaluate((startRank) => {
      const items = document.querySelectorAll('.grid_view li');
      const movieList: any[] = [];
      
      items.forEach((item, index) => {
        const titleElement = item.querySelector('.title');
        const title = titleElement?.textContent?.trim() || '';
        
        const otherElement = item.querySelector('.other');
        const originalTitle = otherElement?.textContent?.trim().replace(/\s*\/\s*/, '') || title;
        
        const bdElement = item.querySelector('.bd p');
        const bdText = bdElement?.textContent || '';
        
        const yearMatch = bdText.match(/(\d{4})/);
        const year = yearMatch ? parseInt(yearMatch[1]) : 0;
        
        const ratingElement = item.querySelector('.rating_num');
        const rating = parseFloat(ratingElement?.textContent?.trim() || '0');
        
        const ratingCountElement = item.querySelector('.star span:last-child');
        const ratingCountText = ratingCountElement?.textContent?.trim() || '0';
        const ratingCount = parseInt(ratingCountText.replace(/[^\d]/g, '')) || 0;
        
        const imgElement = item.querySelector('img');
        const coverImageUrl = imgElement?.getAttribute('src') || '';
        
        const linkElement = item.querySelector('.hd a');
        const doubanUrl = linkElement?.getAttribute('href') || '';
        
        const quoteElement = item.querySelector('.inq');
        const quote = quoteElement?.textContent?.trim() || '';
        
        movieList.push({
          title,
          originalTitle,
          year,
          rating,
          ratingCount,
          coverImageUrl,
          doubanUrl,
          quote,
          rank: startRank + index + 1
        });
      });
      
      return movieList;
    }, pageNum * config.itemsPerPage);

    // 为每部电影获取详细信息
    const detailedMovies: Movie[] = [];
    for (let i = 0; i < movies.length; i++) {
      const movie = movies[i];
      console.log(`  Processing movie ${i + 1}/${movies.length}: ${movie.title}`);
      
      // 获取详细信息
      const details = await scrapeMovieDetails(page, movie.doubanUrl);
      
      // 下载封面图片
      const imageFileName = `movie_${movie.rank}.jpg`;
      const localImagePath = path.join(config.imagesDir, imageFileName);
      const relativeImagePath = `./images/${imageFileName}`;
      
      try {
        await downloadImage(movie.coverImageUrl, localImagePath);
        console.log(`    Downloaded image: ${imageFileName}`);
      } catch (error) {
        console.error(`    Failed to download image: ${error}`);
      }
      
      detailedMovies.push({
        ...movie,
        ...details,
        localCoverPath: relativeImagePath,
        directors: details.directors || [],
        actors: details.actors || [],
        genres: details.genres || [],
        countries: details.countries || [],
        duration: details.duration || '',
        summary: details.summary || '',
        releaseDate: details.releaseDate || '',
        language: details.language || '',
        aka: details.aka || []
      });
      
      await delay(config.delayBetweenRequests);
    }
    
    await page.close();
    return detailedMovies;
  } catch (error) {
    console.error(`Error scraping page ${pageNum}:`, error);
    await page.close();
    return [];
  }
}

// 主函数
async function main(): Promise<void> {
  console.log('Starting Douban Top 250 Movies Crawler...');
  console.log('===========================================');
  
  ensureDirectoryExists(config.outputDir);
  ensureDirectoryExists(config.imagesDir);
  
  const browser = await puppeteer.launch({
    headless: false,
    defaultViewport: { width: 1280, height: 800 },
    args: ['--no-sandbox', '--disable-setuid-sandbox']
  });
  
  let allMovies: Movie[] = [];
  
  try {
    for (let i = 0; i < config.totalPages; i++) {
      const movies = await scrapePage(browser, i);
      allMovies = allMovies.concat(movies);
      console.log(`Completed page ${i + 1}/${config.totalPages} - Total movies: ${allMovies.length}`);
      await delay(config.delayBetweenRequests);
    }
    
    const outputPath = path.join(config.outputDir, 'movies.json');
    fs.writeFileSync(outputPath, JSON.stringify(allMovies, null, 2), 'utf-8');
    console.log('===========================================');
    console.log(`Successfully scraped ${allMovies.length} movies!`);
    console.log(`Data saved to: ${outputPath}`);
    console.log(`Images saved to: ${config.imagesDir}`);
  } catch (error) {
    console.error('Error during scraping:', error);
  } finally {
    await browser.close();
  }
}

main().catch(console.error);
--------------------  END  --------------------


FILE_PATH: types.ts
-------------------- START --------------------
export interface Movie {
  title: string;
  originalTitle: string;
  year: number;
  rating: number;
  ratingCount: number;
  directors: string[];
  actors: string[];
  genres: string[];
  countries: string[];
  duration: string;
  summary: string;
  coverImageUrl: string;
  localCoverPath: string;
  doubanUrl: string;
  rank: number;
  quote?: string;
  releaseDate: string;
  imdbId?: string;
  language: string;
  aka: string[];
}

export interface ScraperConfig {
  baseUrl: string;
  totalPages: number;
  itemsPerPage: number;
  outputDir: string;
  imagesDir: string;
  delayBetweenRequests: number;
}
--------------------  END  --------------------


FILE_PATH: backend\.env
-------------------- START --------------------
MONGODB_URI=mongodb://localhost:27017/movie_management
PORT=3000
JWT_SECRET=your-secret-key-change-in-production
NODE_ENV=development
--------------------  END  --------------------


FILE_PATH: backend\check-system.js
-------------------- START --------------------
const mongoose = require('mongoose');
const http = require('http');

console.log('='.repeat(60));
console.log('电影管理系统 - 系统诊断工具');
console.log('='.repeat(60));
console.log('');

const MONGODB_URI = process.env.MONGODB_URI || 'mongodb://localhost:27017/movie_management';
const BACKEND_PORT = process.env.PORT || 3000;

// 颜色输出
const colors = {
  reset: '\x1b[0m',
  green: '\x1b[32m',
  red: '\x1b[31m',
  yellow: '\x1b[33m',
  blue: '\x1b[34m'
};

function success(msg) {
  console.log(`${colors.green}✓${colors.reset} ${msg}`);
}

function error(msg) {
  console.log(`${colors.red}✗${colors.reset} ${msg}`);
}

function warning(msg) {
  console.log(`${colors.yellow}⚠${colors.reset} ${msg}`);
}

function info(msg) {
  console.log(`${colors.blue}ℹ${colors.reset} ${msg}`);
}

async function checkMongoDB() {
  console.log('\n【1/4】检查 MongoDB 连接...');
  try {
    await mongoose.connect(MONGODB_URI, {
      serverSelectionTimeoutMS: 5000
    });
    success('MongoDB 连接成功');
    
    const db = mongoose.connection.db;
    const collections = await db.listCollections().toArray();
    const collectionNames = collections.map(c => c.name);
    
    info(`找到 ${collections.length} 个集合: ${collectionNames.join(', ')}`);
    
    if (collectionNames.includes('movies')) {
      const movieCount = await db.collection('movies').countDocuments();
      if (movieCount > 0) {
        success(`电影数据库包含 ${movieCount} 部电影`);
      } else {
        error('电影数据库为空！');
        warning('请运行: npm run import');
      }
    } else {
      error('未找到 movies 集合！');
      warning('请运行: npm run import');
    }
    
    if (collectionNames.includes('users')) {
      const userCount = await db.collection('users').countDocuments();
      info(`用户数据库包含 ${userCount} 个用户`);
    }
    
    await mongoose.connection.close();
    return true;
  } catch (err) {
    error('MongoDB 连接失败！');
    error(`错误信息: ${err.message}`);
    warning('请确保 MongoDB 已启动: mongod --dbpath "C:\\data\\db"');
    return false;
  }
}

function checkBackendServer() {
  return new Promise((resolve) => {
    console.log('\n【2/4】检查后端服务...');
    
    const options = {
      hostname: 'localhost',
      port: BACKEND_PORT,
      path: '/api/health',
      method: 'GET',
      timeout: 3000
    };
    
    const req = http.request(options, (res) => {
      if (res.statusCode === 200) {
        success(`后端服务运行正常 (http://localhost:${BACKEND_PORT})`);
        resolve(true);
      } else {
        warning(`后端服务响应异常 (状态码: ${res.statusCode})`);
        resolve(false);
      }
    });
    
    req.on('error', () => {
      error('无法连接到后端服务！');
      warning('请启动后端: cd backend && npm run dev');
      resolve(false);
    });
    
    req.on('timeout', () => {
      error('连接后端服务超时！');
      req.destroy();
      resolve(false);
    });
    
    req.end();
  });
}

function checkFrontendServer() {
  return new Promise((resolve) => {
    console.log('\n【3/4】检查前端服务...');
    
    const options = {
      hostname: 'localhost',
      port: 5173,
      path: '/',
      method: 'GET',
      timeout: 3000
    };
    
    const req = http.request(options, (res) => {
      if (res.statusCode === 200) {
        success('前端服务运行正常 (http://localhost:5173)');
        resolve(true);
      } else {
        warning(`前端服务响应异常 (状态码: ${res.statusCode})`);
        resolve(false);
      }
    });
    
    req.on('error', () => {
      error('无法连接到前端服务！');
      warning('请启动前端: cd frontend && npm run dev');
      resolve(false);
    });
    
    req.on('timeout', () => {
      error('连接前端服务超时！');
      req.destroy();
      resolve(false);
    });
    
    req.end();
  });
}

function checkEnvironment() {
  console.log('\n【4/4】检查环境配置...');
  
  const nodeVersion = process.version;
  const requiredVersion = 'v16.0.0';
  
  if (nodeVersion >= requiredVersion) {
    success(`Node.js 版本: ${nodeVersion}`);
  } else {
    warning(`Node.js 版本: ${nodeVersion} (建议 >= ${requiredVersion})`);
  }
  
  info(`MongoDB URI: ${MONGODB_URI}`);
  info(`后端端口: ${BACKEND_PORT}`);
  
  const fs = require('fs');
  const path = require('path');
  
  const envPath = path.join(__dirname, '.env');
  if (fs.existsSync(envPath)) {
    success('.env 配置文件存在');
  } else {
    warning('.env 配置文件不存在（将使用默认配置）');
  }
  
  const imagesDir = path.join(__dirname, '../crawler/data/images');
  if (fs.existsSync(imagesDir)) {
    const imageFiles = fs.readdirSync(imagesDir);
    if (imageFiles.length > 0) {
      success(`找到 ${imageFiles.length} 个电影海报图片`);
    } else {
      warning('电影海报目录为空');
      info('图片将从网络加载，可能较慢');
    }
  } else {
    warning('未找到电影海报目录');
  }
}

async function main() {
  const mongoOk = await checkMongoDB();
  const backendOk = await checkBackendServer();
  const frontendOk = await checkFrontendServer();
  checkEnvironment();
  
  console.log('\n' + '='.repeat(60));
  console.log('诊断结果汇总');
  console.log('='.repeat(60));
  
  console.log(`MongoDB:    ${mongoOk ? colors.green + '✓ 正常' : colors.red + '✗ 异常'}${colors.reset}`);
  console.log(`后端服务:   ${backendOk ? colors.green + '✓ 正常' : colors.red + '✗ 异常'}${colors.reset}`);
  console.log(`前端服务:   ${frontendOk ? colors.green + '✓ 正常' : colors.red + '✗ 异常'}${colors.reset}`);
  
  console.log('\n');
  
  if (mongoOk && backendOk && frontendOk) {
    success('系统运行正常！');
    info('访问: http://localhost:5173');
  } else {
    error('系统存在问题，请根据上述提示修复！');
    console.log('\n常见问题解决：');
    console.log('1. MongoDB 未启动 → 运行: mongod --dbpath "C:\\data\\db"');
    console.log('2. 数据库为空 → 运行: npm run import');
    console.log('3. 后端未启动 → 运行: cd backend && npm run dev');
    console.log('4. 前端未启动 → 运行: cd frontend && npm run dev');
  }
  
  console.log('\n');
  process.exit(mongoOk && backendOk && frontendOk ? 0 : 1);
}

main().catch(err => {
  console.error('诊断过程出错:', err);
  process.exit(1);
});
--------------------  END  --------------------


FILE_PATH: backend\chi_sim.traineddata
-------------------- START --------------------
FILE_PATH: backend\eng.traineddata
-------------------- START --------------------
FILE_PATH: backend\package.json
-------------------- START --------------------
{
  "name": "movie-backend",
  "version": "1.0.0",
  "description": "Movie Management System Backend",
  "main": "dist/server.js",
  "scripts": {
    "dev": "nodemon --exec ts-node src/server.ts",
    "build": "tsc",
    "start": "node dist/server.js",
    "import": "ts-node src/utils/importData.ts"
  },
  "keywords": [
    "movie",
    "backend",
    "api"
  ],
  "author": "",
  "license": "MIT",
  "dependencies": {
    "bcryptjs": "^2.4.3",
    "cors": "^2.8.5",
    "dotenv": "^16.6.1",
    "express": "^4.22.1",
    "jsonwebtoken": "^9.0.3",
    "mongoose": "^8.20.4",
    "multer": "^1.4.5-lts.1",
    "tesseract.js": "^5.1.1"
  },
  "devDependencies": {
    "@types/bcryptjs": "^2.4.6",
    "@types/cors": "^2.8.19",
    "@types/express": "^4.17.25",
    "@types/jsonwebtoken": "^9.0.10",
    "@types/multer": "^1.4.13",
    "@types/node": "^20.19.27",
    "nodemon": "^3.1.11",
    "ts-node": "^10.9.2",
    "typescript": "^5.9.3"
  }
}

--------------------  END  --------------------


FILE_PATH: backend\tsconfig.json
-------------------- START --------------------
{
  "compilerOptions": {
    "target": "ES2020",
    "module": "commonjs",
    "lib": ["ES2020"],
    "outDir": "./dist",
    "rootDir": "./src",
    "strict": true,
    "esModuleInterop": true,
    "skipLibCheck": true,
    "forceConsistentCasingInFileNames": true,
    "resolveJsonModule": true,
    "moduleResolution": "node"
  },
  "include": ["src/**/*"],
  "exclude": ["node_modules"]
}
--------------------  END  --------------------


FILE_PATH: backend\src\server.ts
-------------------- START --------------------
import express, { Application, Request, Response } from 'express';
import mongoose from 'mongoose';
import cors from 'cors';
import dotenv from 'dotenv';
import bcrypt from 'bcryptjs';
import jwt from 'jsonwebtoken';
import multer from 'multer';
import path from 'path';
import { createWorker } from 'tesseract.js';

import Movie from './models/Movie';
import User from './models/User';
import { Comment } from './models/Comment';
import { Favorite } from './models/Favorite';
import { authenticateToken, AuthRequest } from './middleware/auth';

dotenv.config();
const app: Application = express();
const PORT = process.env.PORT || 3000;
const MONGODB_URI = process.env.MONGODB_URI || 'mongodb://localhost:27017/movie_management';
const JWT_SECRET = process.env.JWT_SECRET || 'your-secret-key-change-in-production';

app.use(cors());
app.use(express.json());
app.use(express.urlencoded({ extended: true }));

app.use('/uploads', express.static(path.join(__dirname, '../uploads')));
app.use('/images', express.static(path.join(__dirname, '../../crawler/data/images')));

const storage = multer.diskStorage({
  destination: (req, file, cb) => {
    cb(null, path.join(__dirname, '../uploads'));
  },
  filename: (req, file, cb) => {
    const uniqueSuffix = Date.now() + '-' + Math.round(Math.random() * 1E9);
    cb(null, file.fieldname + '-' + uniqueSuffix + path.extname(file.originalname));
  }
});
const upload = multer({ storage });

const connectDB = async () => {
  const maxRetries = 3;
  let retries = 0;

  while (retries < maxRetries) {
    try {
      console.log(`正在连接 MongoDB... (尝试 ${retries + 1}/${maxRetries})`);
      
      await mongoose.connect(MONGODB_URI, {
        serverSelectionTimeoutMS: 10000,
        socketTimeoutMS: 45000,
        connectTimeoutMS: 10000,
        maxPoolSize: 10,
        minPoolSize: 2,
      });
      
      console.log('✓ MongoDB connected successfully');
      return;
    } catch (error: any) {
      retries++;
      console.error(`✗ MongoDB 连接失败 (尝试 ${retries}/${maxRetries})`);
      console.error(`错误: ${error.message}`);
      
      if (retries < maxRetries) {
        console.log(`等待 3 秒后重试...`);
        await new Promise(resolve => setTimeout(resolve, 3000));
      } else {
        console.error('✗ MongoDB 连接失败，已达到最大重试次数');
        console.error('提示：请确保 MongoDB 正在运行: mongod --dbpath "C:\\data\\db"');
      }
    }
  }
};

connectDB();

app.post('/api/auth/register', async (req: Request, res: Response): Promise<void> => {
  try {
    const { username, password, email } = req.body;

    const existingUser = await User.findOne({ username });
    if (existingUser) {
      res.status(400).json({ message: '用户名已存在' });
      return;
    }

    const hashedPassword = await bcrypt.hash(password, 10);
    const user = new User({
      username,
      password: hashedPassword,
      email
    });

    await user.save();
    res.status(201).json({ message: '注册成功', userId: user._id });
  } catch (error: any) {
    res.status(500).json({ message: '注册失败', error: error.message });
  }
});

app.post('/api/auth/login', async (req: Request, res: Response): Promise<void> => {
  try {
    const { username, password } = req.body;

    const user = await User.findOne({ username });
    if (!user) {
      res.status(401).json({ message: '用户名或密码错误' });
      return;
    }

    const isValidPassword = await bcrypt.compare(password, user.password);
    if (!isValidPassword) {
      res.status(401).json({ message: '用户名或密码错误' });
      return;
    }

    const token = jwt.sign(
      { id: user._id, username: user.username },
      JWT_SECRET,
      { expiresIn: '7d' }
    );

    res.json({
      message: '登录成功',
      token,
      user: {
        id: user._id,
        username: user.username,
        email: user.email
      }
    });
  } catch (error: any) {
    res.status(500).json({ message: '登录失败', error: error.message });
  }
});

app.get('/api/movies', async (req: Request, res: Response): Promise<void> => {
  try {
    const page = parseInt(req.query.page as string) || 1;
    const limit = parseInt(req.query.limit as string) || 20;
    const search = req.query.search as string || '';
    const genre = req.query.genre as string || '';
    const sortBy = req.query.sortBy as string || 'rank';
    const order = req.query.order as string || 'asc';

    let query: any = {};

    if (search) {
      query.$or = [
        { title: { $regex: search, $options: 'i' } },
        { originalTitle: { $regex: search, $options: 'i' } },
        { directors: { $regex: search, $options: 'i' } },
        { actors: { $regex: search, $options: 'i' } }
      ];
    }

    if (genre) {
      query.genres = genre;
    }

    const sortOptions: any = {};
    sortOptions[sortBy] = order === 'asc' ? 1 : -1;

    const total = await Movie.countDocuments(query);
    const movies = await Movie.find(query)
      .sort(sortOptions)
      .skip((page - 1) * limit)
      .limit(limit);
    
    res.json({
      movies,
      total,
      page,
      pages: Math.ceil(total / limit)
    });
  } catch (error: any) {
    res.status(500).json({ message: '获取电影列表失败', error: error.message });
  }
});

app.get('/api/movies/fulltext-search', async (req: Request, res: Response): Promise<void> => {
  try {
    const query = req.query.q as string;
    const page = parseInt(req.query.page as string) || 1;
    const limit = parseInt(req.query.limit as string) || 20;

    if (!query) {
      res.status(400).json({ message: '请提供搜索关键词' });
      return;
    }

    const movies = await Movie.find(
      { $text: { $search: query } },
      { score: { $meta: 'textScore' } }
    )
      .sort({ score: { $meta: 'textScore' } })
      .skip((page - 1) * limit)
      .limit(limit);

    const total = await Movie.countDocuments({ $text: { $search: query } });

    res.json({
      movies,
      total,
      page,
      pages: Math.ceil(total / limit)
    });
  } catch (error: any) {
    res.status(500).json({ message: '全文检索失败', error: error.message });
  }
});

app.get('/api/movies/advanced-search', async (req: Request, res: Response): Promise<void> => {
  try {
    const {
      title,
      genre,
      year,
      minRating,
      maxRating,
      country,
      director,
      actor,
      page = '1',
      limit = '20'
    } = req.query;

    let query: any = {};

    if (title) query.title = { $regex: title, $options: 'i' };
    if (genre) query.genres = genre;
    if (year) query.year = parseInt(year as string);
    if (minRating || maxRating) {
      query.rating = {};
      if (minRating) query.rating.$gte = parseFloat(minRating as string);
      if (maxRating) query.rating.$lte = parseFloat(maxRating as string);
    }
    if (country) query.countries = { $regex: country, $options: 'i' };
    if (director) query.directors = { $regex: director, $options: 'i' };
    if (actor) query.actors = { $regex: actor, $options: 'i' };

    const pageNum = parseInt(page as string);
    const limitNum = parseInt(limit as string);
    const total = await Movie.countDocuments(query);
    const movies = await Movie.find(query)
      .sort({ rank: 1 })
      .skip((pageNum - 1) * limitNum)
      .limit(limitNum);
    
    res.json({
      movies,
      total,
      page: pageNum,
      pages: Math.ceil(total / limitNum)
    });
  } catch (error: any) {
    res.status(500).json({ message: '高级搜索失败', error: error.message });
  }
});

app.get('/api/movies/:id', async (req: Request, res: Response): Promise<void> => {
  try {
    const movie = await Movie.findById(req.params.id);
    if (!movie) {
      res.status(404).json({ message: '电影不存在' });
      return;
    }
    res.json(movie);
  } catch (error: any) {
    res.status(500).json({ message: '获取电影详情失败', error: error.message });
  }
});

app.post('/api/movies', authenticateToken, upload.single('image'), async (req: AuthRequest, res: Response): Promise<void> => {
  try {
    const movieData = req.body;
    
    if (req.file) {
      movieData.localCoverPath = `/uploads/${req.file.filename}`;
    }

    ['directors', 'actors', 'genres', 'countries', 'aka'].forEach(field => {
      if (typeof movieData[field] === 'string') {
        movieData[field] = movieData[field].split(',').map((s: string) => s.trim());
      }
    });

    if (!movieData.rank || movieData.rank <= 0) {
      const maxRankMovie = await Movie.findOne().sort({ rank: -1 }).limit(1);
      movieData.rank = maxRankMovie ? maxRankMovie.rank + 1 : 1;
      console.log(`自动分配rank: ${movieData.rank}`);
    } else {
      const existingMovie = await Movie.findOne({ rank: movieData.rank });
      if (existingMovie) {
        res.status(400).json({ 
          message: `排名 ${movieData.rank} 已被电影《${existingMovie.title}》占用，请使用其他排名或留空自动分配` 
        });
        return;
      }
    }

    const movie = new Movie(movieData);
    await movie.save();

    res.status(201).json({ message: '电影添加成功', movie });
  } catch (error: any) {
    console.error('添加电影错误:', error);
    res.status(500).json({ message: '添加电影失败', error: error.message });
  }
});

app.put('/api/movies/:id', authenticateToken, upload.single('image'), async (req: AuthRequest, res: Response): Promise<void> => {
  try {
    const updateData = req.body;
    
    if (req.file) {
      updateData.localCoverPath = `/uploads/${req.file.filename}`;
    }

    ['directors', 'actors', 'genres', 'countries', 'aka'].forEach(field => {
      if (typeof updateData[field] === 'string') {
        updateData[field] = updateData[field].split(',').map((s: string) => s.trim());
      }
    });

    if (updateData.rank) {
      const existingMovie = await Movie.findOne({ 
        rank: updateData.rank, 
        _id: { $ne: req.params.id } 
      });
      if (existingMovie) {
        res.status(400).json({ 
          message: `排名 ${updateData.rank} 已被电影《${existingMovie.title}》占用，请使用其他排名` 
        });
        return;
      }
    }

    const movie = await Movie.findByIdAndUpdate(
      req.params.id,
      updateData,
      { new: true, runValidators: true }
    );

    if (!movie) {
      res.status(404).json({ message: '电影不存在' });
      return;
    }

    res.json({ message: '电影更新成功', movie });
  } catch (error: any) {
    res.status(500).json({ message: '更新电影失败', error: error.message });
  }
});

app.delete('/api/movies/:id', authenticateToken, async (req: AuthRequest, res: Response): Promise<void> => {
  try {
    const movie = await Movie.findByIdAndDelete(req.params.id);
    if (!movie) {
      res.status(404).json({ message: '电影不存在' });
      return;
    }

    await Comment.deleteMany({ movieId: req.params.id });
    await Favorite.deleteMany({ movieId: req.params.id });

    res.json({ message: '电影删除成功' });
  } catch (error: any) {
    res.status(500).json({ message: '删除电影失败', error: error.message });
  }
});

app.get('/api/movies/export/data', authenticateToken, async (req: AuthRequest, res: Response): Promise<void> => {
  try {
    const format = req.query.format as string || 'json';
    const movies = await Movie.find({}).sort({ rank: 1 });

    if (format === 'json') {
      res.setHeader('Content-Type', 'application/json');
      res.setHeader('Content-Disposition', 'attachment; filename=movies.json');
      res.send(JSON.stringify(movies, null, 2));
    } else if (format === 'csv') {
      let csv = 'Rank,Title,Year,Rating,Directors,Genres\n';
      movies.forEach(movie => {
        csv += `${movie.rank},"${movie.title}",${movie.year},${movie.rating},"${movie.directors.join(', ')}","${movie.genres.join(', ')}"\n`;
      });
      res.setHeader('Content-Type', 'text/csv');
      res.setHeader('Content-Disposition', 'attachment; filename=movies.csv');
      res.send(csv);
    } else {
      res.status(400).json({ message: '不支持的导出格式' });
    }
  } catch (error: any) {
    res.status(500).json({ message: '导出数据失败', error: error.message });
  }
});

app.get('/api/stats/overview', async (req: Request, res: Response): Promise<void> => {
  try {
    const totalMovies = await Movie.countDocuments();
    const avgRating = await Movie.aggregate([
      { $group: { _id: null, avg: { $avg: '$rating' } } }
    ]);

    const genreStats = await Movie.aggregate([
      { $unwind: '$genres' },
      { $group: { _id: '$genres', count: { $sum: 1 } } },
      { $sort: { count: -1 } },
      { $limit: 10 }
    ]);

    res.json({
      totalMovies,
      avgRating: avgRating[0]?.avg || 0,
      topGenres: genreStats
    });
  } catch (error: any) {
    res.status(500).json({ message: '获取统计概览失败', error: error.message });
  }
});

app.get('/api/stats/rating-distribution', async (req: Request, res: Response): Promise<void> => {
  try {
    const distribution = await Movie.aggregate([
      {
        $bucket: {
          groupBy: '$rating',
          boundaries: [0, 5, 6, 7, 8, 9, 10],
          default: 'Other',
          output: { count: { $sum: 1 } }
        }
      }
    ]);

    const boundaries = [0, 5, 6, 7, 8, 9];
    const resultMap = new Map<number, number>();
    distribution.forEach((item: any) => {
      if (typeof item._id === 'number') {
        resultMap.set(item._id, item.count);
      }
    });

    const result = boundaries.map(boundary => ({
      boundary: boundary,
      label: boundary === 9 ? '9-10' : `${boundary}-${boundary + 1}`,
      count: resultMap.get(boundary) || 0
    }));

    res.json(result);
  } catch (error: any) {
    res.status(500).json({ message: '获取评分分布失败', error: error.message });
  }
});

app.get('/api/stats/year-distribution', async (req: Request, res: Response): Promise<void> => {
  try {
    const distribution = await Movie.aggregate([
      { $group: { _id: '$year', count: { $sum: 1 } } },
      { $sort: { _id: 1 } }
    ]);

    res.json(distribution);
  } catch (error: any) {
    res.status(500).json({ message: '获取年份分布失败', error: error.message });
  }
});

app.get('/api/comments/:movieId', async (req: Request, res: Response): Promise<void> => {
  try {
    const comments = await Comment.find({ movieId: req.params.movieId })
      .sort({ createdAt: -1 });
    res.json(comments);
  } catch (error: any) {
    res.status(500).json({ message: '获取评论失败', error: error.message });
  }
});

app.post('/api/comments/:movieId', authenticateToken, async (req: AuthRequest, res: Response): Promise<void> => {
  try {
    const { content, rating } = req.body;
    
    const comment = new Comment({
      movieId: req.params.movieId,
      userId: req.user!.id,
      username: req.user!.username,
      content,
      rating
    });

    await comment.save();
    res.status(201).json({ message: '评论添加成功', comment });
  } catch (error: any) {
    res.status(500).json({ message: '添加评论失败', error: error.message });
  }
});

app.delete('/api/comments/:id', authenticateToken, async (req: AuthRequest, res: Response): Promise<void> => {
  try {
    const comment = await Comment.findById(req.params.id);
    
    if (!comment) {
      res.status(404).json({ message: '评论不存在' });
      return;
    }

    if (comment.userId.toString() !== req.user!.id) {
      res.status(403).json({ message: '无权删除此评论' });
      return;
    }

    await Comment.findByIdAndDelete(req.params.id);
    res.json({ message: '评论删除成功' });
  } catch (error: any) {
    res.status(500).json({ message: '删除评论失败', error: error.message });
  }
});

app.get('/api/favorites', authenticateToken, async (req: AuthRequest, res: Response): Promise<void> => {
  try {
    const favorites = await Favorite.find({ userId: req.user!.id })
      .populate('movieId');
    
    const movies = favorites.map((fav: any) => fav.movieId);
    res.json(movies);
  } catch (error: any) {
    res.status(500).json({ message: '获取收藏列表失败', error: error.message });
  }
});

app.post('/api/favorites/:movieId', authenticateToken, async (req: AuthRequest, res: Response): Promise<void> => {
  try {
    const existing = await Favorite.findOne({
      userId: req.user!.id,
      movieId: req.params.movieId
    });

    if (existing) {
      res.status(400).json({ message: '已经收藏过了' });
      return;
    }

    const favorite = new Favorite({
      userId: req.user!.id,
      movieId: req.params.movieId
    });

    await favorite.save();
    res.status(201).json({ message: '收藏成功' });
  } catch (error: any) {
    res.status(500).json({ message: '收藏失败', error: error.message });
  }
});

app.delete('/api/favorites/:movieId', authenticateToken, async (req: AuthRequest, res: Response): Promise<void> => {
  try {
    await Favorite.findOneAndDelete({
      userId: req.user!.id,
      movieId: req.params.movieId
    });

    res.json({ message: '取消收藏成功' });
  } catch (error: any) {
    res.status(500).json({ message: '取消收藏失败', error: error.message });
  }
});

app.get('/api/favorites/check/:movieId', authenticateToken, async (req: AuthRequest, res: Response): Promise<void> => {
  try {
    const favorite = await Favorite.findOne({
      userId: req.user!.id,
      movieId: req.params.movieId
    });

    res.json({ isFavorited: !!favorite });
  } catch (error: any) {
    res.status(500).json({ message: '检查收藏状态失败', error: error.message });
  }
});

app.get('/api/recommendations', authenticateToken, async (req: AuthRequest, res: Response): Promise<void> => {
  try {
    const favorites = await Favorite.find({ userId: req.user!.id }).populate('movieId');
    
    if (favorites.length === 0) {
      const movies = await Movie.find({}).sort({ rating: -1 }).limit(10);
      res.json(movies);
      return;
    }

    const genres: string[] = [];
    favorites.forEach((fav: any) => {
      if (fav.movieId && fav.movieId.genres) {
        genres.push(...fav.movieId.genres);
      }
    });

    const genreCount: { [key: string]: number } = {};
    genres.forEach(genre => {
      genreCount[genre] = (genreCount[genre] || 0) + 1;
    });

    const topGenres = Object.keys(genreCount)
      .sort((a, b) => genreCount[b] - genreCount[a])
      .slice(0, 3);

    const favoritedIds = favorites.map((fav: any) => fav.movieId._id);
    
    const recommendations = await Movie.find({
      genres: { $in: topGenres },
      _id: { $nin: favoritedIds }
    })
      .sort({ rating: -1 })
      .limit(10);
    
    res.json(recommendations);
  } catch (error: any) {
    res.status(500).json({ message: '获取推荐失败', error: error.message });
  }
});

app.post('/api/ocr', upload.single('image'), async (req: Request, res: Response): Promise<void> => {
  try {
    if (!req.file) {
      res.status(400).json({ message: '请上传图片' });
      return;
    }

    const imagePath = req.file.path;
    const worker = await createWorker('chi_sim+eng');
    
    const { data: { text } } = await worker.recognize(imagePath);
    await worker.terminate();

    res.json({ text });
  } catch (error: any) {
    res.status(500).json({ message: 'OCR识别失败', error: error.message });
  }
});

app.get('/api/health', (req: Request, res: Response) => {
  res.json({ status: 'ok', message: 'Server is running' });
});

app.listen(PORT, () => {
  console.log(`Server is running on http://localhost:${PORT}`);
  console.log(`Environment: ${process.env.NODE_ENV || 'development'}`);
});

export default app;
--------------------  END  --------------------


FILE_PATH: backend\src\middleware\auth.ts
-------------------- START --------------------
import { Request, Response, NextFunction } from 'express';
import jwt from 'jsonwebtoken';

const JWT_SECRET = process.env.JWT_SECRET || 'your-secret-key-change-in-production';

export interface AuthRequest extends Request {
  user?: {
    id: string;
    username: string;
  };
}

export const authenticateToken = (
  req: AuthRequest, 
  res: Response, 
  next: NextFunction
): void => {
  const authHeader = req.headers['authorization'];
  const token = authHeader && authHeader.split(' ')[1];

  if (!token) {
    res.status(401).json({ message: '未提供认证令牌' });
    return;
  }

  try {
    const decoded = jwt.verify(token, JWT_SECRET) as { id: string; username: string };
    req.user = decoded;
    next();
  } catch (error) {
    console.error('JWT验证失败:', error);
    res.status(403).json({ message: '无效的令牌' });
  }
};
--------------------  END  --------------------


FILE_PATH: backend\src\models\Comment.ts
-------------------- START --------------------
import mongoose, { Schema, Document } from 'mongoose';

export interface IComment extends Document {
  movieId: mongoose.Types.ObjectId;
  userId: mongoose.Types.ObjectId;
  username: string;
  content: string;
  rating?: number;
  createdAt: Date;
  updatedAt: Date;
}

const CommentSchema: Schema = new Schema({
  movieId: { 
    type: Schema.Types.ObjectId, 
    ref: 'Movie', 
    required: true,
    index: true
  },
  userId: { 
    type: Schema.Types.ObjectId, 
    ref: 'User', 
    required: true 
  },
  username: { 
    type: String, 
    required: true 
  },
  content: { 
    type: String, 
    required: true,
    maxlength: 1000
  },
  rating: { 
    type: Number,
    min: 0,
    max: 10
  }
}, {
  timestamps: true
});

export const Comment = mongoose.model<IComment>('Comment', CommentSchema);
--------------------  END  --------------------


FILE_PATH: backend\src\models\Favorite.ts
-------------------- START --------------------
import mongoose, { Schema, Document } from 'mongoose';

export interface IFavorite extends Document {
  userId: mongoose.Types.ObjectId;
  movieId: mongoose.Types.ObjectId;
  createdAt: Date;
}

const FavoriteSchema: Schema = new Schema({
  userId: { 
    type: Schema.Types.ObjectId, 
    ref: 'User', 
    required: true,
    index: true
  },
  movieId: { 
    type: Schema.Types.ObjectId, 
    ref: 'Movie', 
    required: true 
  }
}, {
  timestamps: true
});

// 确保用户不能重复收藏同一部电影
FavoriteSchema.index({ userId: 1, movieId: 1 }, { unique: true });

export const Favorite = mongoose.model<IFavorite>('Favorite', FavoriteSchema);
--------------------  END  --------------------


FILE_PATH: backend\src\models\Movie.ts
-------------------- START --------------------
import mongoose, { Schema, Document } from 'mongoose';

export interface IMovie extends Document {
  title: string;
  originalTitle: string;
  year: number;
  rating: number;
  ratingCount: number;
  directors: string[];
  actors: string[];
  genres: string[];
  countries: string[];
  duration: string;
  summary: string;
  coverImageUrl: string;
  localCoverPath: string;
  doubanUrl: string;
  rank: number;
  quote?: string;
  releaseDate: string;
  imdbId?: string;
  language: string;
  aka: string[];
  createdAt: Date;
  updatedAt: Date;
}

const MovieSchema: Schema = new Schema({
  title: { type: String, required: true, index: true },
  originalTitle: { type: String, required: true },
  year: { type: Number, required: true, index: true },
  rating: { type: Number, required: true, index: true },
  ratingCount: { type: Number, default: 0 },
  directors: [{ type: String }],
  actors: [{ type: String }],
  genres: [{ type: String, index: true }],
  countries: [{ type: String }],
  duration: { type: String },
  summary: { type: String, text: true },
  coverImageUrl: { type: String },
  localCoverPath: { type: String },
  doubanUrl: { type: String },
  rank: { type: Number, unique: true },
  quote: { type: String },
  releaseDate: { type: String },
  imdbId: { type: String },
  language: { type: String },
  aka: [{ type: String }]
}, {
  timestamps: true
});

MovieSchema.index(
  { title: 'text', summary: 'text', originalTitle: 'text' },
  { language_override: 'none' }
);

export default mongoose.model<IMovie>('Movie', MovieSchema);
--------------------  END  --------------------


FILE_PATH: backend\src\models\User.ts
-------------------- START --------------------
import mongoose, { Schema, Document } from 'mongoose';

export interface IUser extends Document {
  username: string;
  password: string;
  email?: string;
  createdAt: Date;
  updatedAt: Date;
}

const UserSchema: Schema = new Schema({
  username: { 
    type: String, 
    required: true, 
    unique: true,
    trim: true,
    minlength: 3
  },
  password: { 
    type: String, 
    required: true,
    minlength: 6
  },
  email: { 
    type: String,
    trim: true,
    lowercase: true
  }
}, {
  timestamps: true
});

export default mongoose.model<IUser>('User', UserSchema);
--------------------  END  --------------------


FILE_PATH: backend\src\routes\auth.ts
-------------------- START --------------------

--------------------  END  --------------------


FILE_PATH: backend\src\routes\comments.ts
-------------------- START --------------------

--------------------  END  --------------------


FILE_PATH: backend\src\routes\favorites.ts
-------------------- START --------------------

--------------------  END  --------------------


FILE_PATH: backend\src\routes\movies.ts
-------------------- START --------------------

--------------------  END  --------------------


FILE_PATH: backend\src\routes\stats.ts
-------------------- START --------------------

--------------------  END  --------------------


FILE_PATH: backend\src\utils\importData.ts
-------------------- START --------------------
import mongoose from 'mongoose';
import * as fs from 'fs';
import * as path from 'path';
import Movie from '../models/Movie';

const MONGODB_URI = process.env.MONGODB_URI || 'mongodb://localhost:27017/movie_management';
const JSON_FILE_PATH = path.join(__dirname, '../../../crawler/data/movies.json');

async function importData() {
  try {
    console.log('Connecting to MongoDB...');
    await mongoose.connect(MONGODB_URI);
    console.log('MongoDB connected successfully');

    console.log('Reading movies data from:', JSON_FILE_PATH);
    const jsonData = fs.readFileSync(JSON_FILE_PATH, 'utf-8');
    const movies = JSON.parse(jsonData);
    console.log(`Found ${movies.length} movies to import`);

    console.log('Clearing existing movies...');
    await Movie.deleteMany({});

    console.log('Importing movies...');
    let successCount = 0;
    let errorCount = 0;

    for (const movieData of movies) {
      try {
        const movie = new Movie(movieData);
        await movie.save();
        successCount++;
        if (successCount % 10 === 0) {
          console.log(`Imported ${successCount}/${movies.length} movies...`);
        }
      } catch (error: any) {
        errorCount++;
        console.error(`Error importing movie "${movieData.title}":`, error.message);
      }
    }

    console.log('\n===========================================');
    console.log('Import completed!');
    console.log(`Successfully imported: ${successCount} movies`);
    console.log(`Failed: ${errorCount} movies`);
    console.log('===========================================\n');

    console.log('Creating text index for full-text search...');
    
    try {
      await Movie.collection.dropIndexes();
    } catch (e) {
      // 忽略索引不存在的错误
    }

    await Movie.collection.createIndex(
      { title: 'text', summary: 'text', originalTitle: 'text' },
      { language_override: 'none' }
    );
    
    console.log('Text index created successfully');

    await mongoose.connection.close();
    console.log('Database connection closed');
    process.exit(0);
  } catch (error) {
    console.error('Import failed:', error);
    await mongoose.connection.close();
    process.exit(1);
  }
}

importData();
--------------------  END  --------------------


FILE_PATH: backend\src\utils\ocr.ts
-------------------- START --------------------

--------------------  END  --------------------


FILE_PATH: crawler\package.json
-------------------- START --------------------
{
  "name": "movie-crawler",
  "version": "1.0.0",
  "description": "Douban Top 250 Movies Crawler",
  "main": "dist/scraper.js",
  "scripts": {
    "scrape": "ts-node src/scraper.ts",
    "build": "tsc",
    "start": "node dist/scraper.js"
  },
  "keywords": [
    "crawler",
    "puppeteer",
    "douban"
  ],
  "author": "",
  "license": "MIT",
  "dependencies": {
    "@types/node": "^20.19.27",
    "puppeteer": "^21.11.0",
    "ts-node": "^10.9.2",
    "typescript": "^5.9.3"
  },
  "devDependencies": {
    "@types/puppeteer": "^7.0.4"
  }
}

--------------------  END  --------------------


FILE_PATH: crawler\tsconfig.json
-------------------- START --------------------
{
  "compilerOptions": {
    "target": "ES2020",
    "module": "commonjs",
    "lib": ["ES2020", "DOM"],
    "outDir": "./dist",
    "rootDir": "./src",
    "strict": true,
    "esModuleInterop": true,
    "skipLibCheck": true,
    "forceConsistentCasingInFileNames": true,
    "resolveJsonModule": true
  },
  "include": ["src/**/*"],
  "exclude": ["node_modules"]
}
--------------------  END  --------------------


FILE_PATH: crawler\src\scraper.ts
-------------------- START --------------------
import puppeteer, { Browser, Page } from 'puppeteer';
import * as fs from 'fs';
import * as path from 'path';
import * as https from 'https';
import { Movie, ScraperConfig } from './types';

const config: ScraperConfig = {
  baseUrl: 'https://movie.douban.com/top250',
  totalPages: 10,
  itemsPerPage: 25,
  outputDir: path.join(__dirname, '../data'),
  imagesDir: path.join(__dirname, '../data/images'),
  delayBetweenRequests: 2000
};

// 创建必要的目录
function ensureDirectoryExists(dir: string): void {
  if (!fs.existsSync(dir)) {
    fs.mkdirSync(dir, { recursive: true });
    console.log(`Created directory: ${dir}`);
  }
}

// 下载图片
function downloadImage(url: string, filepath: string): Promise<void> {
  return new Promise((resolve, reject) => {
    const file = fs.createWriteStream(filepath);
    https.get(url, (response) => {
      response.pipe(file);
      file.on('finish', () => {
        file.close();
        resolve();
      });
    }).on('error', (err) => {
      fs.unlink(filepath, () => {});
      reject(err);
    });
  });
}

// 延迟函数
function delay(ms: number): Promise<void> {
  return new Promise(resolve => setTimeout(resolve, ms));
}

// 提取电影详细信息
async function scrapeMovieDetails(page: Page, movieUrl: string): Promise<Partial<Movie>> {
  try {
    await page.goto(movieUrl, { waitUntil: 'networkidle2', timeout: 30000 });
    await delay(1000);

    const details = await page.evaluate(() => {
      const info: any = {};
      
      // 获取基本信息
      const infoDiv = document.querySelector('#info');
      if (infoDiv) {
        const text = infoDiv.textContent || '';
        
        // 导演
        const directorMatch = text.match(/导演:(.*?)(?:编剧|主演|类型|$)/s);
        if (directorMatch) {
          info.directors = directorMatch[1].trim().split('/').map((d: string) => d.trim()).filter((d: string) => d);
        }
        
        // 主演
        const actorMatch = text.match(/主演:(.*?)(?:类型|制片国家|$)/s);
        if (actorMatch) {
          info.actors = actorMatch[1].trim().split('/').map((a: string) => a.trim()).filter((a: string) => a).slice(0, 5);
        }
        
        // 类型
        const genreMatch = text.match(/类型:(.*?)(?:制片国家|语言|$)/s);
        if (genreMatch) {
          info.genres = genreMatch[1].trim().split('/').map((g: string) => g.trim()).filter((g: string) => g);
        }
        
        // 国家
        const countryMatch = text.match(/制片国家\/地区:(.*?)(?:语言|上映日期|$)/s);
        if (countryMatch) {
          info.countries = countryMatch[1].trim().split('/').map((c: string) => c.trim()).filter((c: string) => c);
        }
        
        // 语言
        const languageMatch = text.match(/语言:(.*?)(?:上映日期|片长|$)/s);
        if (languageMatch) {
          info.language = languageMatch[1].trim();
        }
        
        // 上映日期
        const dateMatch = text.match(/上映日期:(.*?)(?:片长|又名|$)/s);
        if (dateMatch) {
          info.releaseDate = dateMatch[1].trim().split('/')[0].trim();
        }
        
        // 片长
        const durationMatch = text.match(/片长:(.*?)(?:又名|IMDb|$)/s);
        if (durationMatch) {
          info.duration = durationMatch[1].trim();
        }
        
        // 又名
        const akaMatch = text.match(/又名:(.*?)$/s);
        if (akaMatch) {
          info.aka = akaMatch[1].trim().split('/').map((a: string) => a.trim()).filter((a: string) => a);
        }
        
        // IMDb
        const imdbMatch = text.match(/IMDb:(.*?)$/s);
        if (imdbMatch) {
          info.imdbId = imdbMatch[1].trim();
        }
      }
      
      // 获取简介
      const summarySpan = document.querySelector('span[property="v:summary"]');
      if (summarySpan) {
        info.summary = summarySpan.textContent?.trim() || '';
      }
      
      return info;
    });

    return details;
  } catch (error) {
    console.error(`Error scraping details for ${movieUrl}:`, error);
    return {};
  }
}

// 爬取单页电影列表
async function scrapePage(browser: Browser, pageNum: number): Promise<Movie[]> {
  const page = await browser.newPage();
  const url = `${config.baseUrl}?start=${pageNum * config.itemsPerPage}`;
  
  console.log(`Scraping page ${pageNum + 1}...`);
  console.log(`URL: ${url}`);
  
  try {
    await page.goto(url, { waitUntil: 'networkidle2', timeout: 30000 });
    await delay(1000);

    const movies = await page.evaluate((startRank) => {
      const items = document.querySelectorAll('.grid_view li');
      const movieList: any[] = [];
      
      items.forEach((item, index) => {
        const titleElement = item.querySelector('.title');
        const title = titleElement?.textContent?.trim() || '';
        
        const otherElement = item.querySelector('.other');
        const originalTitle = otherElement?.textContent?.trim().replace(/\s*\/\s*/, '') || title;
        
        const bdElement = item.querySelector('.bd p');
        const bdText = bdElement?.textContent || '';
        
        const yearMatch = bdText.match(/(\d{4})/);
        const year = yearMatch ? parseInt(yearMatch[1]) : 0;
        
        const ratingElement = item.querySelector('.rating_num');
        const rating = parseFloat(ratingElement?.textContent?.trim() || '0');
        
        const ratingCountElement = item.querySelector('.star span:last-child');
        const ratingCountText = ratingCountElement?.textContent?.trim() || '0';
        const ratingCount = parseInt(ratingCountText.replace(/[^\d]/g, '')) || 0;
        
        const imgElement = item.querySelector('img');
        const coverImageUrl = imgElement?.getAttribute('src') || '';
        
        const linkElement = item.querySelector('.hd a');
        const doubanUrl = linkElement?.getAttribute('href') || '';
        
        const quoteElement = item.querySelector('.inq');
        const quote = quoteElement?.textContent?.trim() || '';
        
        movieList.push({
          title,
          originalTitle,
          year,
          rating,
          ratingCount,
          coverImageUrl,
          doubanUrl,
          quote,
          rank: startRank + index + 1
        });
      });
      
      return movieList;
    }, pageNum * config.itemsPerPage);

    // 为每部电影获取详细信息
    const detailedMovies: Movie[] = [];
    for (let i = 0; i < movies.length; i++) {
      const movie = movies[i];
      console.log(`  Processing movie ${i + 1}/${movies.length}: ${movie.title}`);
      
      // 获取详细信息
      const details = await scrapeMovieDetails(page, movie.doubanUrl);
      
      // 下载封面图片
      const imageFileName = `movie_${movie.rank}.jpg`;
      const localImagePath = path.join(config.imagesDir, imageFileName);
      const relativeImagePath = `./images/${imageFileName}`;
      
      try {
        await downloadImage(movie.coverImageUrl, localImagePath);
        console.log(`    Downloaded image: ${imageFileName}`);
      } catch (error) {
        console.error(`    Failed to download image: ${error}`);
      }
      
      detailedMovies.push({
        ...movie,
        ...details,
        localCoverPath: relativeImagePath,
        directors: details.directors || [],
        actors: details.actors || [],
        genres: details.genres || [],
        countries: details.countries || [],
        duration: details.duration || '',
        summary: details.summary || '',
        releaseDate: details.releaseDate || '',
        language: details.language || '',
        aka: details.aka || []
      });
      
      await delay(config.delayBetweenRequests);
    }
    
    await page.close();
    return detailedMovies;
  } catch (error) {
    console.error(`Error scraping page ${pageNum}:`, error);
    await page.close();
    return [];
  }
}

// 主函数
async function main(): Promise<void> {
  console.log('Starting Douban Top 250 Movies Crawler...');
  console.log('===========================================');
  
  ensureDirectoryExists(config.outputDir);
  ensureDirectoryExists(config.imagesDir);
  
  const browser = await puppeteer.launch({
    headless: false,
    defaultViewport: { width: 1280, height: 800 },
    args: ['--no-sandbox', '--disable-setuid-sandbox']
  });
  
  let allMovies: Movie[] = [];
  
  try {
    for (let i = 0; i < config.totalPages; i++) {
      const movies = await scrapePage(browser, i);
      allMovies = allMovies.concat(movies);
      console.log(`Completed page ${i + 1}/${config.totalPages} - Total movies: ${allMovies.length}`);
      await delay(config.delayBetweenRequests);
    }
    
    const outputPath = path.join(config.outputDir, 'movies.json');
    fs.writeFileSync(outputPath, JSON.stringify(allMovies, null, 2), 'utf-8');
    console.log('===========================================');
    console.log(`Successfully scraped ${allMovies.length} movies!`);
    console.log(`Data saved to: ${outputPath}`);
    console.log(`Images saved to: ${config.imagesDir}`);
  } catch (error) {
    console.error('Error during scraping:', error);
  } finally {
    await browser.close();
  }
}

main().catch(console.error);
--------------------  END  --------------------


FILE_PATH: crawler\src\types.ts
-------------------- START --------------------
export interface Movie {
  title: string;
  originalTitle: string;
  year: number;
  rating: number;
  ratingCount: number;
  directors: string[];
  actors: string[];
  genres: string[];
  countries: string[];
  duration: string;
  summary: string;
  coverImageUrl: string;
  localCoverPath: string;
  doubanUrl: string;
  rank: number;
  quote?: string;
  releaseDate: string;
  imdbId?: string;
  language: string;
  aka: string[];
}

export interface ScraperConfig {
  baseUrl: string;
  totalPages: number;
  itemsPerPage: number;
  outputDir: string;
  imagesDir: string;
  delayBetweenRequests: number;
}
--------------------  END  --------------------


FILE_PATH: frontend\index.html
-------------------- START --------------------
<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    <meta charset="UTF-8" />
    <link rel="icon" type="image/svg+xml" href="/vite.svg" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>电影管理系统</title>
  </head>
  <body>
    <div id="app"></div>
    <script type="module" src="/src/main.ts"></script>
  </body>
</html>
--------------------  END  --------------------


FILE_PATH: frontend\package.json
-------------------- START --------------------
{
  "name": "movie-frontend",
  "version": "1.0.0",
  "type": "module",
  "scripts": {
    "dev": "vite",
    "build": "vue-tsc && vite build",
    "preview": "vite preview"
  },
  "dependencies": {
    "@element-plus/icons-vue": "^2.3.2",
    "axios": "^1.13.2",
    "echarts": "^5.6.0",
    "element-plus": "^2.13.0",
    "vue": "^3.3.11",
    "vue-router": "^4.6.4"
  },
  "devDependencies": {
    "@types/node": "^20.10.5",
    "@vitejs/plugin-vue": "^4.5.2",
    "typescript": "^5.3.3",
    "vite": "^5.0.8",
    "vue-tsc": "^1.8.25"
  }
}

--------------------  END  --------------------


FILE_PATH: frontend\tsconfig.json
-------------------- START --------------------
{
  "compilerOptions": {
    "target": "ES2020",
    "useDefineForClassFields": true,
    "module": "ESNext",
    "lib": ["ES2020", "DOM", "DOM.Iterable"],
    "skipLibCheck": true,
    "moduleResolution": "bundler",
    "allowImportingTsExtensions": true,
    "resolveJsonModule": true,
    "isolatedModules": true,
    "noEmit": true,
    "jsx": "preserve",
    "strict": true,
    "noUnusedLocals": true,
    "noUnusedParameters": true,
    "noFallthroughCasesInSwitch": true,
    "paths": {
      "@/*": ["./src/*"]
    }
  },
  "include": ["src/**/*.ts", "src/**/*.d.ts", "src/**/*.tsx", "src/**/*.vue"],
  "references": [{ "path": "./tsconfig.node.json" }]
}
--------------------  END  --------------------


FILE_PATH: frontend\tsconfig.node.json
-------------------- START --------------------
{
  "compilerOptions": {
    "composite": true,
    "skipLibCheck": true,
    "module": "ESNext",
    "moduleResolution": "bundler",
    "allowSyntheticDefaultImports": true
  },
  "include": ["vite.config.ts"]
}
--------------------  END  --------------------


FILE_PATH: frontend\vite.config.ts
-------------------- START --------------------
import { defineConfig } from 'vite'
import vue from '@vitejs/plugin-vue'
import path from 'path'

export default defineConfig({
  plugins: [vue()],
  resolve: {
    alias: {
      '@': path.resolve(__dirname, 'src')
    }
  },
  server: {
    port: 5173,
    proxy: {
      '/api': {
        target: 'http://localhost:3000',
        changeOrigin: true
      },
      '/uploads': {
        target: 'http://localhost:3000',
        changeOrigin: true
      },
      '/images': {
        target: 'http://localhost:3000',
        changeOrigin: true
      }
    }
  }
})
--------------------  END  --------------------


FILE_PATH: frontend\src\App.vue
-------------------- START --------------------
<template>
  <router-view />
</template>

<script setup lang="ts">
</script>

<style>
* {
  margin: 0;
  padding: 0;
  box-sizing: border-box;
}

body {
  font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen,
    Ubuntu, Cantarell, 'Helvetica Neue', sans-serif;
  background-color: #f5f7fa;
}

#app {
  min-height: 100vh;
}
</style>
--------------------  END  --------------------


FILE_PATH: frontend\src\main.ts
-------------------- START --------------------
import { createApp } from 'vue';
import ElementPlus from 'element-plus';
import 'element-plus/dist/index.css';
import * as ElementPlusIconsVue from '@element-plus/icons-vue';
import App from './App.vue';
import router from './router';
import './assets/styles/main.css';

const app = createApp(App);

// 注册所有图标
for (const [key, component] of Object.entries(ElementPlusIconsVue)) {
  app.component(key, component);
}

app.use(router);
app.use(ElementPlus);
app.mount('#app');
--------------------  END  --------------------


FILE_PATH: frontend\src\api\index.ts
-------------------- START --------------------
import axios from 'axios';
import type { Movie, User, Comment, LoginData, RegisterData } from '../types';

const api = axios.create({
  baseURL: '/api',
  timeout: 30000
});

// 请求拦截器：添加token
api.interceptors.request.use(
  (config) => {
    const token = localStorage.getItem('token');
    if (token) {
      config.headers.Authorization = `Bearer ${token}`;
    }
    return config;
  },
  (error) => Promise.reject(error)
);

// 响应拦截器：处理错误
api.interceptors.response.use(
  (response) => response,
  (error) => {
    if (error.response?.status === 401) {
      localStorage.removeItem('token');
      localStorage.removeItem('user');
      window.location.href = '/login';
    }
    return Promise.reject(error);
  }
);

// 认证API
export const authAPI = {
  login: (data: LoginData) => api.post('/auth/login', data),
  register: (data: RegisterData) => api.post('/auth/register', data)
};

// 电影API
export const movieAPI = {
  getList: (params?: any) => api.get('/movies', { params }),
  getDetail: (id: string) => api.get(`/movies/${id}`),
  create: (data: FormData) => api.post('/movies', data, {
    headers: { 'Content-Type': 'multipart/form-data' }
  }),
  update: (id: string, data: FormData) => api.put(`/movies/${id}`, data, {
    headers: { 'Content-Type': 'multipart/form-data' }
  }),
  delete: (id: string) => api.delete(`/movies/${id}`),
  fullTextSearch: (params: any) => api.get('/movies/fulltext-search', { params }),
  advancedSearch: (params: any) => api.get('/movies/advanced-search', { params }),
  export: (format: string) => api.get(`/movies/export/data?format=${format}`, {
    responseType: 'blob'
  })
};

// 统计API
export const statsAPI = {
  getOverview: () => api.get('/stats/overview'),
  getRatingDistribution: () => api.get('/stats/rating-distribution'),
  getYearDistribution: () => api.get('/stats/year-distribution')
};

// 评论API
export const commentAPI = {
  getList: (movieId: string) => api.get(`/comments/${movieId}`),
  create: (movieId: string, data: { content: string; rating?: number }) =>
    api.post(`/comments/${movieId}`, data),
  delete: (id: string) => api.delete(`/comments/${id}`)
};

// 收藏API
export const favoriteAPI = {
  getList: () => api.get('/favorites'),
  add: (movieId: string) => api.post(`/favorites/${movieId}`),
  remove: (movieId: string) => api.delete(`/favorites/${movieId}`),
  check: (movieId: string) => api.get(`/favorites/check/${movieId}`)
};

// 推荐API
export const recommendationAPI = {
  get: () => api.get('/recommendations')
};

// OCR API
export const ocrAPI = {
  recognize: (file: File) => {
    const formData = new FormData();
    formData.append('image', file);
    return api.post('/ocr', formData, {
      headers: { 'Content-Type': 'multipart/form-data' }
    });
  }
};

export default api;
--------------------  END  --------------------


FILE_PATH: frontend\src\assets\styles\main.css
-------------------- START --------------------
:root {
  --primary-color: #409eff;
  --success-color: #67c23a;
  --warning-color: #e6a23c;
  --danger-color: #f56c6c;
  --info-color: #909399;
}

* {
  box-sizing: border-box;
}

body {
  margin: 0;
  font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', 'Oxygen',
    'Ubuntu', 'Cantarell', 'Fira Sans', 'Droid Sans', 'Helvetica Neue',
    sans-serif;
  -webkit-font-smoothing: antialiased;
  -moz-osx-font-smoothing: grayscale;
}

code {
  font-family: source-code-pro, Menlo, Monaco, Consolas, 'Courier New', monospace;
}

.el-card {
  border-radius: 8px;
}

.el-button {
  border-radius: 4px;
}

/* 自定义滚动条 */
::-webkit-scrollbar {
  width: 8px;
  height: 8px;
}

::-webkit-scrollbar-track {
  background: #f1f1f1;
}

::-webkit-scrollbar-thumb {
  background: #888;
  border-radius: 4px;
}

::-webkit-scrollbar-thumb:hover {
  background: #555;
}
--------------------  END  --------------------


FILE_PATH: frontend\src\components\ChartComponent.vue
-------------------- START --------------------
<template>
  <div ref="chartRef" class="chart-container" :style="{ height: height + 'px' }"></div>
</template>

<script setup lang="ts">
import { ref, onMounted, onUnmounted, watch } from 'vue';
import * as echarts from 'echarts';
import type { EChartsOption } from 'echarts';

interface Props {
  option: EChartsOption;
  height?: number;
}

const props = withDefaults(defineProps<Props>(), {
  height: 400
});

const chartRef = ref<HTMLDivElement>();
let chartInstance: echarts.ECharts | null = null;

const initChart = () => {
  if (!chartRef.value) return;
  
  chartInstance = echarts.init(chartRef.value);
  chartInstance.setOption(props.option);
};

const resizeChart = () => {
  chartInstance?.resize();
};

watch(() => props.option, (newOption) => {
  if (chartInstance) {
    chartInstance.setOption(newOption, true);
  }
}, { deep: true });

onMounted(() => {
  initChart();
  window.addEventListener('resize', resizeChart);
});

onUnmounted(() => {
  window.removeEventListener('resize', resizeChart);
  chartInstance?.dispose();
});
</script>

<style scoped>
.chart-container {
  width: 100%;
}
</style>
--------------------  END  --------------------


FILE_PATH: frontend\src\components\CommentSection.vue
-------------------- START --------------------
<template>
  <div class="comment-section">
    <div class="comment-header">
      <h3>评论 ({{ comments.length }})</h3>
    </div>

    <!-- 发表评论 -->
    <div v-if="canComment" class="comment-form">
      <el-input
        v-model="newComment"
        type="textarea"
        :rows="3"
        placeholder="写下你的评论..."
        maxlength="500"
        show-word-limit
      />
      <div class="comment-form-actions">
        <el-rate v-model="newRating" :max="10" />
        <el-button type="primary" @click="submitComment" :loading="submitting">
          发表评论
        </el-button>
      </div>
    </div>

    <!-- 评论列表 -->
    <div class="comment-list">
      <div v-for="comment in comments" :key="comment._id" class="comment-item">
        <div class="comment-avatar">
          <el-avatar :size="40">{{ comment.username[0] }}</el-avatar>
        </div>
        <div class="comment-content">
          <div class="comment-header-info">
            <span class="comment-username">{{ comment.username }}</span>
            <el-rate 
              v-if="comment.rating" 
              :model-value="comment.rating" 
              disabled 
              size="small"
              :max="10"
            />
          </div>
          <p class="comment-text">{{ comment.content }}</p>
          <div class="comment-footer">
            <span class="comment-time">{{ formatTime(comment.createdAt) }}</span>
            <el-button 
              v-if="canDelete(comment)" 
              type="danger" 
              text 
              size="small"
              @click="deleteComment(comment._id)"
            >
              删除
            </el-button>
          </div>
        </div>
      </div>

      <el-empty v-if="comments.length === 0" description="暂无评论" />
    </div>
  </div>
</template>

<script setup lang="ts">
import { ref } from 'vue';
import { ElMessage } from 'element-plus';
import type { Comment } from '../types';

interface Props {
  comments: Comment[];
  canComment?: boolean;
  currentUserId?: string;
}

const props = withDefaults(defineProps<Props>(), {
  canComment: true
});

const emit = defineEmits<{
  submit: [data: { content: string; rating?: number }];
  delete: [commentId: string];
}>();

const newComment = ref('');
const newRating = ref(0);
const submitting = ref(false);

const submitComment = async () => {
  if (!newComment.value.trim()) {
    ElMessage.warning('请输入评论内容');
    return;
  }

  submitting.value = true;
  try {
    emit('submit', {
      content: newComment.value,
      rating: newRating.value || undefined
    });
    newComment.value = '';
    newRating.value = 0;
  } finally {
    submitting.value = false;
  }
};

const deleteComment = (commentId: string) => {
  emit('delete', commentId);
};

const canDelete = (comment: Comment) => {
  return props.currentUserId && comment.userId === props.currentUserId;
};

const formatTime = (time: string) => {
  const date = new Date(time);
  const now = new Date();
  const diff = now.getTime() - date.getTime();
  
  const minutes = Math.floor(diff / 60000);
  const hours = Math.floor(diff / 3600000);
  const days = Math.floor(diff / 86400000);
  
  if (minutes < 1) return '刚刚';
  if (minutes < 60) return `${minutes}分钟前`;
  if (hours < 24) return `${hours}小时前`;
  if (days < 7) return `${days}天前`;
  
  return date.toLocaleDateString();
};
</script>

<style scoped>
.comment-section {
  margin-top: 24px;
}

.comment-header h3 {
  margin: 0 0 16px 0;
  font-size: 18px;
  font-weight: 600;
}

.comment-form {
  margin-bottom: 24px;
  padding: 16px;
  background: #f5f7fa;
  border-radius: 8px;
}

.comment-form-actions {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-top: 12px;
}

.comment-list {
  display: flex;
  flex-direction: column;
  gap: 16px;
}

.comment-item {
  display: flex;
  gap: 12px;
  padding: 16px;
  background: white;
  border: 1px solid #e4e7ed;
  border-radius: 8px;
}

.comment-avatar {
  flex-shrink: 0;
}

.comment-content {
  flex: 1;
  min-width: 0;
}

.comment-header-info {
  display: flex;
  align-items: center;
  gap: 12px;
  margin-bottom: 8px;
}

.comment-username {
  font-weight: 600;
  color: #333;
}

.comment-text {
  margin: 0 0 8px 0;
  color: #666;
  line-height: 1.6;
  word-break: break-word;
}

.comment-footer {
  display: flex;
  justify-content: space-between;
  align-items: center;
}

.comment-time {
  font-size: 12px;
  color: #999;
}
</style>
--------------------  END  --------------------


FILE_PATH: frontend\src\components\MovieCard.vue
-------------------- START --------------------
<template>
  <el-card class="movie-card" shadow="hover" @click="handleClick">
    <div class="movie-cover">
      <img :src="imageUrl" :alt="movie.title" />
      <div class="rank-badge">{{ movie.rank }}</div>
    </div>
    
    <div class="movie-info">
      <h3 class="movie-title">{{ movie.title }}</h3>
      <p class="movie-subtitle">{{ movie.originalTitle }}</p>
      
      <div class="movie-rating">
        <el-rate :model-value="movie.rating" disabled :max="10" />
        <span class="rating-text">{{ movie.rating }}</span>
      </div>
      
      <div class="movie-meta">
        <el-tag size="small">{{ movie.year }}</el-tag>
        <el-tag v-for="genre in movie.genres.slice(0, 2)" :key="genre" size="small" type="info">
          {{ genre }}
        </el-tag>
      </div>
    </div>
    
    <div class="movie-actions" @click.stop>
      <slot name="actions"></slot>
    </div>
  </el-card>
</template>

<script setup lang="ts">
import { computed } from 'vue';
import type { Movie } from '../types';

interface Props {
  movie: Movie;
}

const props = defineProps<Props>();
const emit = defineEmits<{
  click: [id: string];
}>();

const imageUrl = computed(() => {
  return props.movie.localCoverPath || props.movie.coverImageUrl || '/placeholder.png';
});

const handleClick = () => {
  emit('click', props.movie._id);
};
</script>

<style scoped>
.movie-card {
  cursor: pointer;
  transition: transform 0.3s;
}

.movie-card:hover {
  transform: translateY(-4px);
}

.movie-cover {
  position: relative;
  width: 100%;
  height: 300px;
  overflow: hidden;
  border-radius: 8px;
  margin-bottom: 12px;
}

.movie-cover img {
  width: 100%;
  height: 100%;
  object-fit: cover;
}

.rank-badge {
  position: absolute;
  top: 8px;
  left: 8px;
  background: rgba(255, 152, 0, 0.9);
  color: white;
  padding: 4px 10px;
  border-radius: 12px;
  font-weight: bold;
  font-size: 12px;
}

.movie-info {
  padding: 8px 0;
}

.movie-title {
  font-size: 16px;
  font-weight: 600;
  margin: 0 0 4px 0;
  overflow: hidden;
  text-overflow: ellipsis;
  white-space: nowrap;
}

.movie-subtitle {
  font-size: 12px;
  color: #999;
  margin: 0 0 8px 0;
  overflow: hidden;
  text-overflow: ellipsis;
  white-space: nowrap;
}

.movie-rating {
  display: flex;
  align-items: center;
  gap: 8px;
  margin-bottom: 8px;
}

.rating-text {
  font-weight: 600;
  color: #ff9900;
}

.movie-meta {
  display: flex;
  flex-wrap: wrap;
  gap: 4px;
}

.movie-actions {
  padding-top: 12px;
  border-top: 1px solid #f0f0f0;
  margin-top: 12px;
}
</style>
--------------------  END  --------------------


FILE_PATH: frontend\src\components\Pagination.vue
-------------------- START --------------------
<template>
  <div class="pagination-wrapper">
    <el-pagination
      v-model:current-page="currentPage"
      v-model:page-size="pageSize"
      :page-sizes="pageSizes"
      :total="total"
      :background="background"
      :layout="layout"
      @size-change="handleSizeChange"
      @current-change="handleCurrentChange"
    />
  </div>
</template>

<script setup lang="ts">
import { ref, watch } from 'vue';

interface Props {
  total: number;
  currentPage?: number;
  pageSize?: number;
  pageSizes?: number[];
  layout?: string;
  background?: boolean;
}

const props = withDefaults(defineProps<Props>(), {
  currentPage: 1,
  pageSize: 20,
  pageSizes: () => [10, 20, 50, 100],
  layout: 'total, sizes, prev, pager, next, jumper',
  background: true
});

const emit = defineEmits<{
  'update:currentPage': [page: number];
  'update:pageSize': [size: number];
  'page-change': [page: number];
  'size-change': [size: number];
}>();

const currentPage = ref(props.currentPage);
const pageSize = ref(props.pageSize);

watch(() => props.currentPage, (val) => {
  currentPage.value = val;
});

watch(() => props.pageSize, (val) => {
  pageSize.value = val;
});

const handleCurrentChange = (page: number) => {
  emit('update:currentPage', page);
  emit('page-change', page);
};

const handleSizeChange = (size: number) => {
  emit('update:pageSize', size);
  emit('size-change', size);
};
</script>

<style scoped>
.pagination-wrapper {
  display: flex;
  justify-content: center;
  padding: 20px 0;
}
</style>
--------------------  END  --------------------


FILE_PATH: frontend\src\components\SearchBar.vue
-------------------- START --------------------
<template>
  <div class="search-bar">
    <el-input
      v-model="searchQuery"
      :placeholder="placeholder"
      :prefix-icon="Search"
      size="large"
      clearable
      @keyup.enter="handleSearch"
      @clear="handleClear"
    >
      <template #append>
        <el-button :icon="Search" @click="handleSearch" />
      </template>
    </el-input>
  </div>
</template>

<script setup lang="ts">
import { ref, watch } from 'vue';
import { Search } from '@element-plus/icons-vue';

interface Props {
  modelValue?: string;
  placeholder?: string;
}

const props = withDefaults(defineProps<Props>(), {
  modelValue: '',
  placeholder: '搜索...'
});

const emit = defineEmits<{
  'update:modelValue': [value: string];
  search: [query: string];
}>();

const searchQuery = ref(props.modelValue);

watch(() => props.modelValue, (val) => {
  searchQuery.value = val;
});

watch(searchQuery, (val) => {
  emit('update:modelValue', val);
});

const handleSearch = () => {
  emit('search', searchQuery.value);
};

const handleClear = () => {
  searchQuery.value = '';
  emit('search', '');
};
</script>

<style scoped>
.search-bar {
  width: 100%;
}
</style>
--------------------  END  --------------------


FILE_PATH: frontend\src\router\index.ts
-------------------- START --------------------
import { createRouter, createWebHistory, RouteRecordRaw } from 'vue-router';

const routes: RouteRecordRaw[] = [
  {
    path: '/login',
    name: 'Login',
    component: () => import('../views/Login.vue')
  },
  {
    path: '/register',
    name: 'Register',
    component: () => import('../views/Register.vue')
  },
  {
    path: '/',
    component: () => import('../views/Dashboard.vue'),
    meta: { requiresAuth: true },
    children: [
      {
        path: '',
        redirect: '/movies'
      },
      {
        path: 'movies',
        name: 'MovieList',
        component: () => import('../views/MovieList.vue')
      },
      {
        path: 'movies/:id',
        name: 'MovieDetail',
        component: () => import('../views/MovieDetail.vue')
      },
      {
        path: 'statistics',
        name: 'Statistics',
        component: () => import('../views/Statistics.vue')
      },
      {
        path: 'search',
        name: 'AdvancedSearch',
        component: () => import('../views/AdvancedSearch.vue')
      },
      {
        path: 'favorites',
        name: 'Favorites',
        component: () => import('../views/Favorites.vue')
      },
      {
        path: 'ocr',
        name: 'OCRTool',
        component: () => import('../views/OCRTool.vue')
      },
      {
        path: 'recommendations',
        name: 'Recommendations',
        component: () => import('../views/Recommendations.vue')
      }
    ]
  }
];

const router = createRouter({
  history: createWebHistory(),
  routes
});

// 路由守卫
router.beforeEach((to, from, next) => {
  const token = localStorage.getItem('token');
  
  if (to.meta.requiresAuth && !token) {
    next('/login');
  } else if ((to.path === '/login' || to.path === '/register') && token) {
    next('/');
  } else {
    next();
  }
});

export default router;
--------------------  END  --------------------


FILE_PATH: frontend\src\types\index.ts
-------------------- START --------------------
export interface Movie {
  _id: string;
  title: string;
  originalTitle: string;
  year: number;
  rating: number;
  ratingCount: number;
  directors: string[];
  actors: string[];
  genres: string[];
  countries: string[];
  duration: string;
  summary: string;
  coverImageUrl: string;
  localCoverPath: string;
  doubanUrl: string;
  rank: number;
  quote?: string;
  releaseDate: string;
  imdbId?: string;
  language: string;
  aka: string[];
  createdAt?: string;
  updatedAt?: string;
}

export interface User {
  id: string;
  username: string;
  email?: string;
}

export interface Comment {
  _id: string;
  movieId: string;
  userId: string;
  username: string;
  content: string;
  rating?: number;
  createdAt: string;
  updatedAt: string;
}

export interface LoginData {
  username: string;
  password: string;
}

export interface RegisterData extends LoginData {
  email?: string;
}
--------------------  END  --------------------


FILE_PATH: frontend\src\views\AdvancedSearch.vue
-------------------- START --------------------
<template>
  <el-card>
    <template #header><h2>高级搜索</h2></template>
    <el-form :model="searchForm" label-width="100px">
      <el-row :gutter="20">
        <el-col :span="12">
          <el-form-item label="标题">
            <el-input v-model="searchForm.title" />
          </el-form-item>
        </el-col>
        <el-col :span="12">
          <el-form-item label="类型">
            <el-select v-model="searchForm.genre" clearable>
              <el-option v-for="g in genres" :key="g" :value="g" />
            </el-select>
          </el-form-item>
        </el-col>
        <el-col :span="12">
          <el-form-item label="年份">
            <el-input-number v-model="searchForm.year" />
          </el-form-item>
        </el-col>
        <el-col :span="12">
          <el-form-item label="评分范围">
            <el-col :span="11">
              <el-input-number v-model="searchForm.minRating" :max="10" />
            </el-col>
            <el-col :span="2" style="text-align: center;">-</el-col>
            <el-col :span="11">
              <el-input-number v-model="searchForm.maxRating" :max="10" />
            </el-col>
          </el-form-item>
        </el-col>
        <el-col :span="12">
          <el-form-item label="导演">
            <el-input v-model="searchForm.director" />
          </el-form-item>
        </el-col>
        <el-col :span="12">
          <el-form-item label="演员">
            <el-input v-model="searchForm.actor" />
          </el-form-item>
        </el-col>
      </el-row>
      <el-form-item>
        <el-button type="primary" @click="search">搜索</el-button>
        <el-button @click="reset">重置</el-button>
      </el-form-item>
    </el-form>
    
    <div v-loading="loading" class="results">
      <el-card v-for="movie in results" :key="movie._id" @click="$router.push(`/movies/${movie._id}`)">
        <el-row :gutter="20">
          <el-col :span="4">
            <img :src="movie.localCoverPath || movie.coverImageUrl" style="width: 100%;" />
          </el-col>
          <el-col :span="20">
            <h3>{{ movie.title }}</h3>
            <el-rate v-model="movie.rating" disabled :max="10" />
            <p>{{ movie.year }} / {{ movie.genres.join(', ') }}</p>
          </el-col>
        </el-row>
      </el-card>
    </div>
  </el-card>
</template>

<script setup lang="ts">
import { ref } from 'vue';
import { movieAPI } from '../api';
import { ElMessage } from 'element-plus';

const loading = ref(false);
const results = ref<any[]>([]);
const genres = ref(['剧情', '喜剧', '动作', '爱情', '科幻', '动画', '悬疑']);
const searchForm = ref({
  title: '', genre: '', year: null, minRating: null, maxRating: null, director: '', actor: ''
});

const search = async () => {
  loading.value = true;
  try {
    const params = Object.fromEntries(Object.entries(searchForm.value).filter(([_, v]) => v !== '' && v !== null));
    const { data } = await movieAPI.advancedSearch(params);
    results.value = data.movies;
    ElMessage.success(`找到 ${data.total} 部电影`);
  } catch (error) {
    ElMessage.error('搜索失败');
  } finally {
    loading.value = false;
  }
};

const reset = () => {
  searchForm.value = { title: '', genre: '', year: null, minRating: null, maxRating: null, director: '', actor: '' };
  results.value = [];
};
</script>

<style scoped>
.results { margin-top: 24px; display: flex; flex-direction: column; gap: 16px; }
</style>
--------------------  END  --------------------


FILE_PATH: frontend\src\views\Dashboard.vue
-------------------- START --------------------
<template>
  <el-container class="dashboard-container">
    <el-aside width="250px" class="sidebar">
      <div class="logo">
        <el-icon :size="32"><Film /></el-icon>
        <span>电影管理系统</span>
      </div>
      
      <el-menu
        :default-active="activeMenu"
        router
        class="sidebar-menu"
        background-color="#2c3e50"
        text-color="#ecf0f1"
        active-text-color="#3498db"
      >
        <el-menu-item index="/movies">
          <el-icon><List /></el-icon>
          <span>电影列表</span>
        </el-menu-item>
        
        <el-menu-item index="/search">
          <el-icon><Search /></el-icon>
          <span>高级搜索</span>
        </el-menu-item>
        
        <el-menu-item index="/favorites">
          <el-icon><Star /></el-icon>
          <span>我的收藏</span>
        </el-menu-item>
        
        <el-menu-item index="/recommendations">
          <el-icon><MagicStick /></el-icon>
          <span>推荐电影</span>
        </el-menu-item>
        
        <el-menu-item index="/statistics">
          <el-icon><DataAnalysis /></el-icon>
          <span>数据统计</span>
        </el-menu-item>
        
        <el-menu-item index="/ocr">
          <el-icon><Picture /></el-icon>
          <span>图片识别</span>
        </el-menu-item>
      </el-menu>
    </el-aside>
    
    <el-container>
      <el-header class="header">
        <div class="header-left">
          <h2>{{ currentTitle }}</h2>
        </div>
        
        <div class="header-right">
          <el-dropdown @command="handleCommand">
            <div class="user-info">
              <el-icon><User /></el-icon>
              <span>{{ username }}</span>
              <el-icon><ArrowDown /></el-icon>
            </div>
            <template #dropdown>
              <el-dropdown-menu>
                <el-dropdown-item command="logout">
                  <el-icon><SwitchButton /></el-icon>
                  退出登录
                </el-dropdown-item>
              </el-dropdown-menu>
            </template>
          </el-dropdown>
        </div>
      </el-header>
      
      <el-main class="main-content">
        <router-view v-slot="{ Component }">
          <transition name="fade" mode="out-in">
            <component :is="Component" />
          </transition>
        </router-view>
      </el-main>
    </el-container>
  </el-container>
</template>

<script setup lang="ts">
import { ref, computed, onMounted } from 'vue';
import { useRouter, useRoute } from 'vue-router';
import { ElMessage, ElMessageBox } from 'element-plus';

const router = useRouter();
const route = useRoute();

const username = ref('');
const activeMenu = computed(() => route.path);

const titles: Record<string, string> = {
  '/movies': '电影列表',
  '/search': '高级搜索',
  '/favorites': '我的收藏',
  '/recommendations': '推荐电影',
  '/statistics': '数据统计',
  '/ocr': '图片文字识别'
};

const currentTitle = computed(() => {
  const path = route.path.split('/')[1] ? `/${route.path.split('/')[1]}` : '/movies';
  return titles[path] || '电影管理系统';
});

onMounted(() => {
  const userStr = localStorage.getItem('user');
  if (userStr) {
    const user = JSON.parse(userStr);
    username.value = user.username;
  }
});

const handleCommand = async (command: string) => {
  if (command === 'logout') {
    try {
      await ElMessageBox.confirm('确定要退出登录吗？', '提示', {
        confirmButtonText: '确定',
        cancelButtonText: '取消',
        type: 'warning'
      });
      
      localStorage.removeItem('token');
      localStorage.removeItem('user');
      ElMessage.success('已退出登录');
      router.push('/login');
    } catch {
      // 取消退出
    }
  }
};
</script>

<style scoped>
.dashboard-container {
  height: 100vh;
  overflow: hidden;
}

.sidebar {
  background-color: #2c3e50;
  color: #ecf0f1;
  overflow-y: auto;
}

.logo {
  display: flex;
  align-items: center;
  gap: 12px;
  padding: 24px 20px;
  font-size: 20px;
  font-weight: 600;
  color: #ecf0f1;
  border-bottom: 1px solid rgba(255, 255, 255, 0.1);
}

.sidebar-menu {
  border: none;
}

.sidebar-menu .el-menu-item {
  border-radius: 0;
  margin: 0;
}

.sidebar-menu .el-menu-item:hover {
  background-color: rgba(52, 152, 219, 0.1) !important;
}

.sidebar-menu .el-menu-item.is-active {
  background-color: rgba(52, 152, 219, 0.2) !important;
  border-left: 3px solid #3498db;
}

.header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  background: white;
  box-shadow: 0 2px 8px rgba(0, 0, 0, 0.05);
  padding: 0 30px;
}

.header-left h2 {
  font-size: 24px;
  font-weight: 600;
  color: #333;
  margin: 0;
}

.header-right {
  display: flex;
  align-items: center;
  gap: 20px;
}

.user-info {
  display: flex;
  align-items: center;
  gap: 8px;
  padding: 8px 16px;
  border-radius: 20px;
  background: #f5f7fa;
  cursor: pointer;
  transition: all 0.3s;
}

.user-info:hover {
  background: #e8ecf0;
}

.main-content {
  background: #f5f7fa;
  padding: 24px;
  overflow-y: auto;
}

.fade-enter-active,
.fade-leave-active {
  transition: opacity 0.2s ease;
}

.fade-enter-from,
.fade-leave-to {
  opacity: 0;
}
</style>
--------------------  END  --------------------


FILE_PATH: frontend\src\views\Favorites.vue
-------------------- START --------------------
<template>
  <div class="favorites-container">
    <el-card>
      <template #header>
        <div class="card-header">
          <h2>我的收藏</h2>
          <el-tag type="info" size="large">共 {{ favoriteMovies.length }} 部电影</el-tag>
        </div>
      </template>

      <el-alert
        v-if="favoriteMovies.length === 0"
        title="还没有收藏电影"
        type="info"
        description="快去收藏你喜欢的电影吧！"
        :closable="false"
        show-icon
        style="margin-bottom: 20px;"
      />

      <div v-loading="loading" class="favorites-grid">
        <el-card 
          v-for="movie in favoriteMovies" 
          :key="movie._id" 
          class="movie-card"
          shadow="hover"
        >
          <div class="movie-cover" @click="viewDetail(movie._id)">
            <img :src="getImageUrl(movie)" :alt="movie.title" />
            <div class="rank-badge">{{ movie.rank }}</div>
            <div class="overlay">
              <el-button type="primary" circle size="large">
                <el-icon><View /></el-icon>
              </el-button>
            </div>
          </div>
          
          <div class="movie-info">
            <h3 class="movie-title" @click="viewDetail(movie._id)">{{ movie.title }}</h3>
            <p class="movie-original-title">{{ movie.originalTitle }}</p>
            
            <div class="movie-meta">
              <el-rate 
                v-model="movie.rating" 
                disabled 
                show-score 
                text-color="#ff9900" 
                :max="10"
                :score-template="`${movie.rating}分`"
              />
            </div>
            
            <div class="movie-details">
              <el-tag size="small" type="info">{{ movie.year }}</el-tag>
              <el-tag 
                v-for="genre in movie.genres.slice(0, 3)" 
                :key="genre" 
                size="small"
                style="margin-left: 5px;"
              >
                {{ genre }}
              </el-tag>
            </div>
            
            <p v-if="movie.quote" class="movie-quote">"{{ movie.quote }}"</p>
            
            <div class="movie-summary">
              <p>{{ truncateSummary(movie.summary) }}</p>
            </div>
          </div>
          
          <div class="movie-actions">
            <el-button 
              size="small" 
              type="primary" 
              @click="viewDetail(movie._id)"
            >
              <el-icon><View /></el-icon>
              查看详情
            </el-button>
            <el-button 
              size="small" 
              type="danger" 
              @click="removeFavorite(movie._id)"
            >
              <el-icon><Delete /></el-icon>
              取消收藏
            </el-button>
          </div>
        </el-card>
      </div>
    </el-card>

    <!-- 统计信息 -->
    <el-row :gutter="20" style="margin-top: 24px;">
      <el-col :span="8">
        <el-card>
          <el-statistic title="收藏总数" :value="favoriteMovies.length">
            <template #prefix>
              <el-icon><Star /></el-icon>
            </template>
          </el-statistic>
        </el-card>
      </el-col>
      <el-col :span="8">
        <el-card>
          <el-statistic 
            title="平均评分" 
            :value="averageRating" 
            :precision="2"
          >
            <template #prefix>
              <el-icon><TrophyBase /></el-icon>
            </template>
          </el-statistic>
        </el-card>
      </el-col>
      <el-col :span="8">
        <el-card>
          <el-statistic title="最喜欢的类型" :value="favoriteGenre">
            <template #prefix>
              <el-icon><Film /></el-icon>
            </template>
          </el-statistic>
        </el-card>
      </el-col>
    </el-row>

    <!-- 类型分布 -->
    <el-card style="margin-top: 24px;">
      <template #header>
        <h3>收藏电影类型分布</h3>
      </template>
      <div class="genre-tags">
        <el-tag 
          v-for="(count, genre) in genreDistribution" 
          :key="genre"
          size="large"
          style="margin: 5px;"
        >
          {{ genre }}: {{ count }}
        </el-tag>
      </div>
    </el-card>
  </div>
</template>

<script setup lang="ts">
import { ref, onMounted, computed } from 'vue';
import { useRouter } from 'vue-router';
import { ElMessage, ElMessageBox } from 'element-plus';
import { favoriteAPI } from '../api';
import type { Movie } from '../types';

const router = useRouter();
const loading = ref(false);
const favoriteMovies = ref<Movie[]>([]);

// 计算平均评分
const averageRating = computed(() => {
  if (favoriteMovies.value.length === 0) return 0;
  const sum = favoriteMovies.value.reduce((acc, movie) => acc + movie.rating, 0);
  return sum / favoriteMovies.value.length;
});

// 计算最喜欢的类型
const favoriteGenre = computed(() => {
  if (favoriteMovies.value.length === 0) return '暂无';
  
  const genreCount: Record<string, number> = {};
  favoriteMovies.value.forEach(movie => {
    movie.genres.forEach(genre => {
      genreCount[genre] = (genreCount[genre] || 0) + 1;
    });
  });
  
  let maxGenre = '';
  let maxCount = 0;
  Object.entries(genreCount).forEach(([genre, count]) => {
    if (count > maxCount) {
      maxCount = count;
      maxGenre = genre;
    }
  });
  
  return maxGenre || '暂无';
});

// 计算类型分布
const genreDistribution = computed(() => {
  const distribution: Record<string, number> = {};
  favoriteMovies.value.forEach(movie => {
    movie.genres.forEach(genre => {
      distribution[genre] = (distribution[genre] || 0) + 1;
    });
  });
  
  // 按数量排序
  return Object.fromEntries(
    Object.entries(distribution).sort((a, b) => b[1] - a[1])
  );
});

// 获取收藏列表
const fetchFavorites = async () => {
  loading.value = true;
  try {
    const { data } = await favoriteAPI.getList();
    favoriteMovies.value = data;
  } catch (error: any) {
    ElMessage.error(error.response?.data?.message || '获取收藏列表失败');
  } finally {
    loading.value = false;
  }
};

// 取消收藏
const removeFavorite = async (movieId: string) => {
  try {
    await ElMessageBox.confirm('确定要取消收藏这部电影吗？', '提示', {
      confirmButtonText: '确定',
      cancelButtonText: '取消',
      type: 'warning'
    });
    
    await favoriteAPI.remove(movieId);
    ElMessage.success('已取消收藏');
    fetchFavorites();
  } catch (error: any) {
    if (error !== 'cancel') {
      ElMessage.error('操作失败');
    }
  }
};

// 查看详情
const viewDetail = (id: string) => {
  router.push(`/movies/${id}`);
};

// 获取图片URL
const getImageUrl = (movie: Movie) => {
  if (movie.localCoverPath) {
    let path = movie.localCoverPath;
    
    if (path.startsWith('./images/')) {
      path = path.replace('./', '/');
    } else if (path.startsWith('./uploads/')) {
      path = path.replace('./', '/');
    }
    
    if (path.startsWith('http://') || path.startsWith('https://')) {
      return path;
    }
    
    return path;
  }
  
  return movie.coverImageUrl || '/placeholder.png';
};

// 截断简介
const truncateSummary = (summary: string, maxLength: number = 80) => {
  if (summary.length <= maxLength) return summary;
  return summary.substring(0, maxLength) + '...';
};

onMounted(() => {
  fetchFavorites();
});
</script>

<style scoped>
.favorites-container {
  max-width: 1400px;
  margin: 0 auto;
}

.card-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
}

.card-header h2 {
  margin: 0;
  font-size: 24px;
  font-weight: 600;
}

.favorites-grid {
  display: grid;
  grid-template-columns: repeat(auto-fill, minmax(280px, 1fr));
  gap: 20px;
  min-height: 200px;
}

.movie-card {
  transition: all 0.3s;
  cursor: pointer;
}

.movie-card:hover {
  transform: translateY(-4px);
}

.movie-cover {
  position: relative;
  width: 100%;
  height: 380px;
  overflow: hidden;
  border-radius: 8px;
  cursor: pointer;
}

.movie-cover img {
  width: 100%;
  height: 100%;
  object-fit: cover;
  transition: transform 0.3s;
}

.movie-cover:hover img {
  transform: scale(1.05);
}

.rank-badge {
  position: absolute;
  top: 12px;
  left: 12px;
  background: rgba(255, 152, 0, 0.95);
  color: white;
  font-weight: bold;
  padding: 6px 12px;
  border-radius: 20px;
  font-size: 14px;
  box-shadow: 0 2px 8px rgba(0, 0, 0, 0.2);
}

.overlay {
  position: absolute;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  background: rgba(0, 0, 0, 0.6);
  display: flex;
  justify-content: center;
  align-items: center;
  opacity: 0;
  transition: opacity 0.3s;
}

.movie-cover:hover .overlay {
  opacity: 1;
}

.movie-info {
  padding: 16px 0;
}

.movie-title {
  font-size: 18px;
  font-weight: 600;
  margin: 0 0 6px 0;
  color: #333;
  overflow: hidden;
  text-overflow: ellipsis;
  white-space: nowrap;
  cursor: pointer;
  transition: color 0.3s;
}

.movie-title:hover {
  color: #409eff;
}

.movie-original-title {
  font-size: 14px;
  color: #999;
  margin: 0 0 12px 0;
  overflow: hidden;
  text-overflow: ellipsis;
  white-space: nowrap;
}

.movie-meta {
  margin-bottom: 12px;
}

.movie-details {
  display: flex;
  flex-wrap: wrap;
  gap: 6px;
  margin-bottom: 12px;
}

.movie-quote {
  font-size: 13px;
  color: #666;
  font-style: italic;
  margin: 8px 0;
  overflow: hidden;
  text-overflow: ellipsis;
  display: -webkit-box;
  -webkit-line-clamp: 2;
  -webkit-box-orient: vertical;
}

.movie-summary {
  font-size: 13px;
  color: #666;
  line-height: 1.6;
  margin-top: 8px;
}

.movie-summary p {
  margin: 0;
}

.movie-actions {
  display: flex;
  gap: 8px;
  padding-top: 12px;
  border-top: 1px solid #f0f0f0;
}

.movie-actions .el-button {
  flex: 1;
}

.genre-tags {
  display: flex;
  flex-wrap: wrap;
}
</style>
--------------------  END  --------------------


FILE_PATH: frontend\src\views\Login.vue
-------------------- START --------------------
<template>
  <div class="login-container">
    <div class="login-box">
      <h1 class="title">电影管理系统</h1>
      <p class="subtitle">登录您的账户</p>
      
      <el-form :model="form" :rules="rules" ref="formRef" class="login-form">
        <el-form-item prop="username">
          <el-input
            v-model="form.username"
            placeholder="用户名"
            prefix-icon="User"
            size="large"
          />
        </el-form-item>
        
        <el-form-item prop="password">
          <el-input
            v-model="form.password"
            type="password"
            placeholder="密码"
            prefix-icon="Lock"
            size="large"
            @keyup.enter="handleLogin"
            show-password
          />
        </el-form-item>
        
        <el-form-item>
          <el-button
            type="primary"
            size="large"
            style="width: 100%"
            :loading="loading"
            @click="handleLogin"
          >
            登录
          </el-button>
        </el-form-item>
      </el-form>
      
      <div class="register-link">
        还没有账户？
        <router-link to="/register">立即注册</router-link>
      </div>
    </div>
  </div>
</template>

<script setup lang="ts">
import { reactive, ref } from 'vue';
import { useRouter } from 'vue-router';
import { ElMessage, type FormInstance, type FormRules } from 'element-plus';
import { authAPI } from '../api';

const router = useRouter();
const formRef = ref<FormInstance>();
const loading = ref(false);

const form = reactive({
  username: '',
  password: ''
});

const rules: FormRules = {
  username: [
    { required: true, message: '请输入用户名', trigger: 'blur' },
    { min: 3, message: '用户名至少3个字符', trigger: 'blur' }
  ],
  password: [
    { required: true, message: '请输入密码', trigger: 'blur' },
    { min: 6, message: '密码至少6个字符', trigger: 'blur' }
  ]
};

const handleLogin = async () => {
  if (!formRef.value) return;
  
  await formRef.value.validate(async (valid) => {
    if (!valid) return;
    
    loading.value = true;
    try {
      const { data } = await authAPI.login(form);
      localStorage.setItem('token', data.token);
      localStorage.setItem('user', JSON.stringify(data.user));
      
      ElMessage.success('登录成功！');
      router.push('/');
    } catch (error: any) {
      ElMessage.error(error.response?.data?.message || '登录失败');
    } finally {
      loading.value = false;
    }
  });
};
</script>

<style scoped>
.login-container {
  display: flex;
  justify-content: center;
  align-items: center;
  min-height: 100vh;
  background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
  padding: 20px;
}

.login-box {
  width: 100%;
  max-width: 400px;
  background: white;
  padding: 40px;
  border-radius: 12px;
  box-shadow: 0 10px 40px rgba(0, 0, 0, 0.1);
}

.title {
  font-size: 28px;
  font-weight: 700;
  color: #333;
  text-align: center;
  margin-bottom: 8px;
}

.subtitle {
  font-size: 14px;
  color: #666;
  text-align: center;
  margin-bottom: 30px;
}

.login-form {
  margin-top: 24px;
}

.register-link {
  text-align: center;
  margin-top: 20px;
  font-size: 14px;
  color: #666;
}

.register-link a {
  color: #667eea;
  text-decoration: none;
  font-weight: 500;
}

.register-link a:hover {
  text-decoration: underline;
}
</style>
--------------------  END  --------------------


FILE_PATH: frontend\src\views\MovieDetail.vue
-------------------- START --------------------
<template>
  <div class="movie-detail-container">
    <el-card v-loading="loading">
      <div v-if="movie" class="movie-detail">
        <el-row :gutter="30">
          <el-col :span="8">
            <div class="movie-poster">
              <img :src="getImageUrl(movie)" :alt="movie.title" />
              <div class="rank-badge">TOP {{ movie.rank }}</div>
            </div>
            
            <div class="action-buttons">
              <el-button 
                type="primary" 
                size="large" 
                style="width: 100%; margin-bottom: 12px;"
                @click="toggleFavorite"
              >
                <el-icon><Star /></el-icon>
                {{ isFavorited ? '取消收藏' : '收藏电影' }}
              </el-button>
              
              <el-button 
                size="large" 
                style="width: 100%;"
                @click="openDouban"
              >
                <el-icon><Link /></el-icon>
                豆瓣链接
              </el-button>
            </div>
          </el-col>
          
          <el-col :span="16">
            <div class="movie-info">
              <h1 class="movie-title">{{ movie.title }}</h1>
              <p class="movie-original-title">{{ movie.originalTitle }}</p>
              
              <div class="movie-rating">
                <el-rate 
                  v-model="movie.rating" 
                  disabled 
                  show-score 
                  :max="10"
                  text-color="#ff9900"
                  :score-template="`${movie.rating}分`"
                />
                <span class="rating-count">{{ movie.ratingCount }} 人评价</span>
              </div>
              
              <el-divider />
              
              <el-descriptions :column="1" border>
                <el-descriptions-item label="导演">
                  {{ movie.directors.join(' / ') }}
                </el-descriptions-item>
                <el-descriptions-item label="主演">
                  {{ movie.actors.join(' / ') }}
                </el-descriptions-item>
                <el-descriptions-item label="类型">
                  <el-tag 
                    v-for="genre in movie.genres" 
                    :key="genre" 
                    style="margin-right: 5px;"
                  >
                    {{ genre }}
                  </el-tag>
                </el-descriptions-item>
                <el-descriptions-item label="制片国家/地区">
                  {{ movie.countries.join(' / ') }}
                </el-descriptions-item>
                <el-descriptions-item label="语言">
                  {{ movie.language }}
                </el-descriptions-item>
                <el-descriptions-item label="上映日期">
                  {{ movie.releaseDate }}
                </el-descriptions-item>
                <el-descriptions-item label="片长">
                  {{ movie.duration }}
                </el-descriptions-item>
                <el-descriptions-item label="年份">
                  {{ movie.year }}
                </el-descriptions-item>
                <el-descriptions-item v-if="movie.imdbId" label="IMDb">
                  {{ movie.imdbId }}
                </el-descriptions-item>
                <el-descriptions-item v-if="movie.aka && movie.aka.length" label="又名">
                  {{ movie.aka.join(' / ') }}
                </el-descriptions-item>
              </el-descriptions>
              
              <el-divider />
              
              <div v-if="movie.quote" class="movie-quote">
                <el-icon><ChatDotRound /></el-icon>
                <span>"{{ movie.quote }}"</span>
              </div>
              
              <div class="movie-summary">
                <h3>剧情简介</h3>
                <p>{{ movie.summary }}</p>
              </div>
            </div>
          </el-col>
        </el-row>
      </div>
    </el-card>
    
    <el-card style="margin-top: 24px;">
      <comment-section
        :comments="comments"
        :can-comment="isLoggedIn"
        :current-user-id="currentUserId"
        @submit="handleCommentSubmit"
        @delete="handleCommentDelete"
      />
    </el-card>
  </div>
</template>

<script setup lang="ts">
import { ref, onMounted, computed } from 'vue';
import { useRoute, useRouter } from 'vue-router';
import { ElMessage, ElMessageBox } from 'element-plus';
import { movieAPI, commentAPI, favoriteAPI } from '../api';
import CommentSection from '../components/CommentSection.vue';
import type { Movie, Comment } from '../types';

const route = useRoute();
const router = useRouter();
const loading = ref(false);
const movie = ref<Movie | null>(null);
const comments = ref<Comment[]>([]);
const isFavorited = ref(false);

const isLoggedIn = computed(() => !!localStorage.getItem('token'));
const currentUserId = computed(() => {
  const userStr = localStorage.getItem('user');
  if (userStr) {
    const user = JSON.parse(userStr);
    return user.id;
  }
  return null;
});

const fetchMovie = async () => {
  loading.value = true;
  try {
    const { data } = await movieAPI.getDetail(route.params.id as string);
    movie.value = data;
    await checkFavoriteStatus();
    await fetchComments();
  } catch (error: any) {
    ElMessage.error('获取电影详情失败');
    router.push('/movies');
  } finally {
    loading.value = false;
  }
};

const checkFavoriteStatus = async () => {
  if (!isLoggedIn.value || !movie.value) return;
  
  try {
    const { data } = await favoriteAPI.check(movie.value._id);
    isFavorited.value = data.isFavorited;
  } catch (error) {
    console.error('检查收藏状态失败', error);
  }
};

const fetchComments = async () => {
  if (!movie.value) return;
  
  try {
    const { data } = await commentAPI.getList(movie.value._id);
    comments.value = data;
  } catch (error) {
    console.error('获取评论失败', error);
  }
};

const toggleFavorite = async () => {
  if (!isLoggedIn.value) {
    ElMessage.warning('请先登录');
    router.push('/login');
    return;
  }
  
  if (!movie.value) return;
  
  try {
    if (isFavorited.value) {
      await favoriteAPI.remove(movie.value._id);
      isFavorited.value = false;
      ElMessage.success('已取消收藏');
    } else {
      await favoriteAPI.add(movie.value._id);
      isFavorited.value = true;
      ElMessage.success('收藏成功');
    }
  } catch (error: any) {
    ElMessage.error(error.response?.data?.message || '操作失败');
  }
};

const handleCommentSubmit = async (data: { content: string; rating?: number }) => {
  if (!movie.value) return;
  
  try {
    await commentAPI.create(movie.value._id, data);
    ElMessage.success('评论发表成功');
    await fetchComments();
  } catch (error: any) {
    ElMessage.error(error.response?.data?.message || '发表评论失败');
  }
};

const handleCommentDelete = async (commentId: string) => {
  try {
    await ElMessageBox.confirm('确定要删除这条评论吗？', '提示', {
      confirmButtonText: '确定',
      cancelButtonText: '取消',
      type: 'warning'
    });
    
    await commentAPI.delete(commentId);
    ElMessage.success('评论已删除');
    await fetchComments();
  } catch (error: any) {
    if (error !== 'cancel') {
      ElMessage.error('删除评论失败');
    }
  }
};

const openDouban = () => {
  if (movie.value && movie.value.doubanUrl) {
    window.open(movie.value.doubanUrl, '_blank');
  }
};

const getImageUrl = (movie: Movie) => {
  if (movie.localCoverPath) {
    let path = movie.localCoverPath;
    
    if (path.startsWith('./images/')) {
      path = path.replace('./', '/');
    } else if (path.startsWith('./uploads/')) {
      path = path.replace('./', '/');
    }
    
    if (path.startsWith('http://') || path.startsWith('https://')) {
      return path;
    }
    
    return path;
  }
  
  return movie.coverImageUrl || '/placeholder.png';
};

onMounted(() => {
  fetchMovie();
});
</script>

<style scoped>
.movie-detail-container {
  max-width: 1400px;
  margin: 0 auto;
}

.movie-detail {
  padding: 20px;
}

.movie-poster {
  position: relative;
  width: 100%;
  border-radius: 8px;
  overflow: hidden;
  box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
  margin-bottom: 20px;
}

.movie-poster img {
  width: 100%;
  display: block;
}

.rank-badge {
  position: absolute;
  top: 16px;
  left: 16px;
  background: rgba(255, 152, 0, 0.95);
  color: white;
  font-weight: bold;
  padding: 8px 16px;
  border-radius: 24px;
  font-size: 16px;
  box-shadow: 0 2px 8px rgba(0, 0, 0, 0.2);
}

.action-buttons {
  margin-top: 20px;
}

.movie-info {
  padding: 0;
}

.movie-title {
  font-size: 32px;
  font-weight: 700;
  color: #333;
  margin: 0 0 12px 0;
}

.movie-original-title {
  font-size: 18px;
  color: #666;
  margin: 0 0 20px 0;
}

.movie-rating {
  display: flex;
  align-items: center;
  gap: 20px;
  margin-bottom: 20px;
}

.rating-count {
  color: #999;
  font-size: 14px;
}

.movie-quote {
  display: flex;
  align-items: center;
  gap: 12px;
  padding: 16px;
  background: #f5f7fa;
  border-radius: 8px;
  margin-bottom: 24px;
  font-size: 16px;
  color: #666;
  font-style: italic;
}

.movie-quote .el-icon {
  font-size: 24px;
  color: #409eff;
}

.movie-summary {
  margin-top: 24px;
}

.movie-summary h3 {
  font-size: 20px;
  font-weight: 600;
  color: #333;
  margin: 0 0 16px 0;
}

.movie-summary p {
  font-size: 15px;
  line-height: 1.8;
  color: #666;
  text-align: justify;
}
</style>
--------------------  END  --------------------


FILE_PATH: frontend\src\views\MovieList.vue
-------------------- START --------------------
<template>
  <div class="movie-list-container">
    <el-card class="search-card">
      <el-row :gutter="20">
        <el-col :span="12">
          <el-input
            v-model="searchQuery"
            placeholder="搜索电影名称、导演、演员..."
            prefix-icon="Search"
            size="large"
            clearable
            @keyup.enter="handleSearch"
          />
        </el-col>
        <el-col :span="6">
          <el-select v-model="selectedGenre" placeholder="选择类型" size="large" clearable @change="handleSearch">
            <el-option label="全部类型" value="" />
            <el-option v-for="genre in genres" :key="genre" :label="genre" :value="genre" />
          </el-select>
        </el-col>
        <el-col :span="3">
          <el-button type="primary" size="large" @click="handleSearch" style="width: 100%">
            搜索
          </el-button>
        </el-col>
        <el-col :span="3">
          <el-button size="large" @click="showAddDialog = true" style="width: 100%">
            <el-icon><Plus /></el-icon>
            添加
          </el-button>
        </el-col>
      </el-row>
      
      <el-row :gutter="20" style="margin-top: 16px;">
        <el-col :span="6">
          <el-button link @click="handleExport('json')">
            <el-icon><Download /></el-icon>
            导出JSON
          </el-button>
        </el-col>
        <el-col :span="6">
          <el-button link @click="handleExport('csv')">
            <el-icon><Download /></el-icon>
            导出CSV
          </el-button>
        </el-col>
      </el-row>
    </el-card>

    <div v-loading="loading" class="movies-grid">
      <el-card 
        v-for="movie in movies" 
        :key="movie._id" 
        class="movie-card"
        shadow="hover"
        @click="viewDetail(movie._id)"
      >
        <div class="movie-cover">
          <img :src="getImageUrl(movie)" :alt="movie.title" />
          <div class="rank-badge">{{ movie.rank }}</div>
        </div>
        <div class="movie-info">
          <h3 class="movie-title">{{ movie.title }}</h3>
          <p class="movie-original-title">{{ movie.originalTitle }}</p>
          <div class="movie-meta">
            <el-rate v-model="movie.rating" disabled show-score text-color="#ff9900" :max="10" />
          </div>
          <div class="movie-details">
            <span>{{ movie.year }}</span>
            <span v-if="movie.genres.length">{{ movie.genres.join(' / ') }}</span>
          </div>
          <p v-if="movie.quote" class="movie-quote">"{{ movie.quote }}"</p>
        </div>
        <div class="movie-actions">
          <el-button size="small" type="primary" @click.stop="viewDetail(movie._id)">查看</el-button>
          <el-button size="small" @click.stop="editMovie(movie)">编辑</el-button>
          <el-button size="small" type="danger" @click.stop="deleteMovie(movie._id)">删除</el-button>
        </div>
      </el-card>
    </div>

    <el-pagination
      v-if="total > 0"
      class="pagination"
      background
      layout="total, prev, pager, next, sizes"
      :total="total"
      :page-size="pageSize"
      :current-page="currentPage"
      :page-sizes="[12, 24, 48, 96]"
      @current-change="handlePageChange"
      @size-change="handleSizeChange"
    />

    <el-dialog 
      v-model="showAddDialog" 
      :title="editingMovie ? '编辑电影' : '添加电影'"
      width="700px"
      destroy-on-close
    >
      <el-form :model="movieForm" label-width="110px">
        <el-row :gutter="20">
          <el-col :span="12">
            <el-form-item label="电影名称" required>
              <el-input v-model="movieForm.title" />
            </el-form-item>
          </el-col>
          <el-col :span="12">
            <el-form-item label="原名" required>
              <el-input v-model="movieForm.originalTitle" />
            </el-form-item>
          </el-col>
        </el-row>

        <el-row :gutter="12">
          <el-col :span="8">
            <el-form-item label="年份" required label-width="70px">
              <el-input-number v-model="movieForm.year" :min="1900" :max="2100" :controls="false" style="width: 100%;" />
            </el-form-item>
          </el-col>
          <el-col :span="8">
            <el-form-item label="评分" required label-width="70px">
              <el-input-number v-model="movieForm.rating" :min="0" :max="10" :step="0.1" :precision="1" :controls="false" style="width: 100%;" />
            </el-form-item>
          </el-col>
          <el-col :span="8" v-if="editingMovie">
            <el-form-item label="排名" label-width="70px">
              <el-input-number v-model="movieForm.rank" :min="1" :controls="false" style="width: 100%;" />
              <el-text size="small" type="info">当前排名：{{ movieForm.rank }}</el-text>
            </el-form-item>
          </el-col>
          <el-col :span="8" v-else>
            <el-form-item label="排名" label-width="70px">
              <el-input value="自动分配" disabled style="width: 100%;" />
            </el-form-item>
          </el-col>
        </el-row>

        <el-row :gutter="20">
          <el-col :span="12">
            <el-form-item label="评分人数">
              <el-input-number v-model="movieForm.ratingCount" :min="0" :controls="false" style="width: 100%;" />
            </el-form-item>
          </el-col>
          <el-col :span="12">
            <el-form-item label="豆瓣链接">
              <el-input v-model="movieForm.doubanUrl" placeholder="https://movie.douban.com/..." />
            </el-form-item>
          </el-col>
        </el-row>

        <el-form-item label="导演">
          <el-input v-model="movieForm.directors" placeholder="多个导演用逗号分隔" />
        </el-form-item>

        <el-form-item label="主演">
          <el-input v-model="movieForm.actors" placeholder="多个演员用逗号分隔" />
        </el-form-item>

        <el-row :gutter="20">
          <el-col :span="12">
            <el-form-item label="类型">
              <el-input v-model="movieForm.genres" placeholder="多个类型用逗号分隔" />
            </el-form-item>
          </el-col>
          <el-col :span="12">
            <el-form-item label="国家/地区">
              <el-input v-model="movieForm.countries" placeholder="多个国家用逗号分隔" />
            </el-form-item>
          </el-col>
        </el-row>

        <el-row :gutter="20">
          <el-col :span="12">
            <el-form-item label="语言">
              <el-input v-model="movieForm.language" placeholder="例如：汉语普通话 / 英语" />
            </el-form-item>
          </el-col>
          <el-col :span="12">
            <el-form-item label="上映日期">
              <el-input v-model="movieForm.releaseDate" placeholder="例如：2023-01-01" />
            </el-form-item>
          </el-col>
        </el-row>

        <el-row :gutter="20">
          <el-col :span="12">
            <el-form-item label="片长">
              <el-input v-model="movieForm.duration" placeholder="例如：142分钟" />
            </el-form-item>
          </el-col>
          <el-col :span="12">
            <el-form-item label="封面图片URL">
              <el-input v-model="movieForm.coverImageUrl" placeholder="在线图片链接" />
            </el-form-item>
          </el-col>
        </el-row>

        <el-form-item label="一句话评价">
          <el-input v-model="movieForm.quote" placeholder="电影的经典台词或评价" />
        </el-form-item>

        <el-form-item label="简介">
          <el-input v-model="movieForm.summary" type="textarea" :rows="4" />
        </el-form-item>

        <el-form-item label="本地封面">
          <el-upload
            action="#"
            :auto-upload="false"
            :on-change="handleFileChange"
            :file-list="fileList"
            accept="image/*"
            :limit="1"
          >
            <el-button size="small">选择文件</el-button>
            <template #tip>
              <div class="el-upload__tip">选择本地图片文件，上传后将自动保存路径</div>
            </template>
          </el-upload>
        </el-form-item>

        <el-form-item label="又名">
          <el-input v-model="movieForm.aka" placeholder="多个别名用逗号分隔" />
        </el-form-item>

        <el-form-item label="IMDb">
          <el-input v-model="movieForm.imdbId" placeholder="例如：tt1234567" />
        </el-form-item>
      </el-form>
      <template #footer>
        <el-button @click="cancelEdit">取消</el-button>
        <el-button type="primary" @click="saveMovie" :loading="saving">保存</el-button>
      </template>
    </el-dialog>

    <el-dialog v-model="showImagePreview" title="图片预览" width="500px">
      <img v-if="previewImageUrl" :src="previewImageUrl" style="width: 100%;" />
    </el-dialog>
  </div>
</template>

<script setup lang="ts">
import { ref, onMounted } from 'vue';
import { useRouter } from 'vue-router';
import { ElMessage, ElMessageBox } from 'element-plus';
import { movieAPI } from '../api';
import type { Movie } from '../types';

const router = useRouter();
const loading = ref(false);
const saving = ref(false);
const movies = ref<Movie[]>([]);
const total = ref(0);
const currentPage = ref(1);
const pageSize = ref(24);
const searchQuery = ref('');
const selectedGenre = ref('');
const showAddDialog = ref(false);
const editingMovie = ref<Movie | null>(null);
const fileList = ref<any[]>([]);
const uploadFile = ref<File | null>(null);
const showImagePreview = ref(false);
const previewImageUrl = ref('');

const genres = ref(['剧情', '喜剧', '动作', '爱情', '科幻', '动画', '悬疑', '惊悚', '恐怖', '犯罪', '冒险', '战争', '历史', '音乐', '传记', '家庭', '奇幻', '武侠', '古装', '西部']);

const movieForm = ref({
  title: '',
  originalTitle: '',
  year: new Date().getFullYear(),
  rating: 0,
  ratingCount: 0,
  directors: '',
  actors: '',
  genres: '',
  countries: '',
  duration: '',
  summary: '',
  coverImageUrl: '',
  doubanUrl: '',
  rank: 0,
  quote: '',
  language: '',
  releaseDate: '',
  localCoverPath: '',
  aka: '',
  imdbId: ''
});

const fetchMovies = async () => {
  loading.value = true;
  try {
    const { data } = await movieAPI.getList({
      page: currentPage.value,
      limit: pageSize.value,
      search: searchQuery.value,
      genre: selectedGenre.value
    });
    movies.value = data.movies;
    total.value = data.total;
  } catch (error) {
    ElMessage.error('获取电影列表失败');
  } finally {
    loading.value = false;
  }
};

const handleSearch = () => {
  currentPage.value = 1;
  fetchMovies();
};

const handlePageChange = (page: number) => {
  currentPage.value = page;
  fetchMovies();
};

const handleSizeChange = (size: number) => {
  pageSize.value = size;
  currentPage.value = 1;
  fetchMovies();
};

const getImageUrl = (movie: Movie) => {
  if (movie.localCoverPath) {
    let path = movie.localCoverPath;
    
    if (path.startsWith('./images/')) {
      path = path.replace('./', '/');
    } else if (path.startsWith('./uploads/')) {
      path = path.replace('./', '/');
    }
    
    if (path.startsWith('http://') || path.startsWith('https://')) {
      return path;
    }
    
    return path;
  }
  
  return movie.coverImageUrl || '/placeholder.png';
};

const viewDetail = (id: string) => {
  router.push(`/movies/${id}`);
};

const editMovie = (movie: Movie) => {
  editingMovie.value = movie;
  movieForm.value = {
    title: movie.title,
    originalTitle: movie.originalTitle,
    year: movie.year,
    rating: movie.rating,
    ratingCount: movie.ratingCount || 0,
    directors: movie.directors.join(', '),
    actors: movie.actors.join(', '),
    genres: movie.genres.join(', '),
    countries: movie.countries.join(', '),
    duration: movie.duration,
    summary: movie.summary,
    coverImageUrl: movie.coverImageUrl || '',
    doubanUrl: movie.doubanUrl || '',
    rank: movie.rank,
    quote: movie.quote || '',
    language: movie.language || '',
    releaseDate: movie.releaseDate || '',
    localCoverPath: movie.localCoverPath || '',
    aka: movie.aka?.join(', ') || '',
    imdbId: movie.imdbId || ''
  };
  fileList.value = [];
  uploadFile.value = null;
  showAddDialog.value = true;
};

const handleFileChange = (file: any) => {
  uploadFile.value = file.raw;
  fileList.value = [file];
};

const previewImage = () => {
  if (movieForm.value.localCoverPath) {
    let path = movieForm.value.localCoverPath;
    if (path.startsWith('./images/')) {
      path = path.replace('./', '/');
    } else if (path.startsWith('./uploads/')) {
      path = path.replace('./', '/');
    }
    previewImageUrl.value = path;
    showImagePreview.value = true;
  }
};

const saveMovie = async () => {
  if (!movieForm.value.title || !movieForm.value.originalTitle) {
    ElMessage.warning('请填写必填字段：电影名称和原名');
    return;
  }

  saving.value = true;
  try {
    const formData = new FormData();
    Object.entries(movieForm.value).forEach(([key, value]) => {
      if (editingMovie.value) {
        if (key !== 'localCoverPath') {
          formData.append(key, String(value));
        }
      } else {
        if (key !== 'localCoverPath' && key !== 'rank') {
          formData.append(key, String(value));
        }
      }
    });
    
    if (uploadFile.value) {
      formData.append('image', uploadFile.value);
    }

    if (editingMovie.value) {
      await movieAPI.update(editingMovie.value._id, formData);
      ElMessage.success('更新成功');
    } else {
      await movieAPI.create(formData);
      ElMessage.success('添加成功');
    }
    
    showAddDialog.value = false;
    fetchMovies();
    resetForm();
  } catch (error: any) {
    const errorMsg = error.response?.data?.message || error.response?.data?.error || '保存失败';
    ElMessage.error(errorMsg);
    console.error('保存电影错误:', error.response?.data);
  } finally {
    saving.value = false;
  }
};

const deleteMovie = async (id: string) => {
  try {
    await ElMessageBox.confirm('确定要删除这部电影吗？', '提示', {
      confirmButtonText: '确定',
      cancelButtonText: '取消',
      type: 'warning'
    });
    
    await movieAPI.delete(id);
    ElMessage.success('删除成功');
    fetchMovies();
  } catch (error: any) {
    if (error !== 'cancel') {
      ElMessage.error('删除失败');
    }
  }
};

const handleExport = async (format: string) => {
  try {
    const { data } = await movieAPI.export(format);
    const url = window.URL.createObjectURL(new Blob([data]));
    const link = document.createElement('a');
    link.href = url;
    link.setAttribute('download', `movies.${format}`);
    document.body.appendChild(link);
    link.click();
    document.body.removeChild(link);
    ElMessage.success('导出成功');
  } catch (error) {
    ElMessage.error('导出失败');
  }
};

const cancelEdit = () => {
  showAddDialog.value = false;
  resetForm();
};

const resetForm = () => {
  editingMovie.value = null;
  movieForm.value = {
    title: '',
    originalTitle: '',
    year: new Date().getFullYear(),
    rating: 0,
    ratingCount: 0,
    directors: '',
    actors: '',
    genres: '',
    countries: '',
    duration: '',
    summary: '',
    coverImageUrl: '',
    doubanUrl: '',
    rank: 0,
    quote: '',
    language: '',
    releaseDate: '',
    localCoverPath: '',
    aka: '',
    imdbId: ''
  };
  fileList.value = [];
  uploadFile.value = null;
};

onMounted(() => {
  fetchMovies();
});
</script>

<style scoped>
.movie-list-container {
  max-width: 1400px;
  margin: 0 auto;
}

.search-card {
  margin-bottom: 24px;
}

.movies-grid {
  display: grid;
  grid-template-columns: repeat(auto-fill, minmax(280px, 1fr));
  gap: 20px;
  margin-bottom: 24px;
}

.movie-card {
  cursor: pointer;
  transition: transform 0.3s;
}

.movie-card:hover {
  transform: translateY(-4px);
}

.movie-cover {
  position: relative;
  width: 100%;
  height: 360px;
  overflow: hidden;
  border-radius: 8px;
}

.movie-cover img {
  width: 100%;
  height: 100%;
  object-fit: cover;
}

.rank-badge {
  position: absolute;
  top: 12px;
  left: 12px;
  background: rgba(255, 152, 0, 0.9);
  color: white;
  font-weight: bold;
  padding: 6px 12px;
  border-radius: 20px;
  font-size: 14px;
}

.movie-info {
  padding: 16px 0;
}

.movie-title {
  font-size: 18px;
  font-weight: 600;
  margin: 0 0 6px 0;
  color: #333;
  overflow: hidden;
  text-overflow: ellipsis;
  white-space: nowrap;
}

.movie-original-title {
  font-size: 14px;
  color: #999;
  margin: 0 0 12px 0;
  overflow: hidden;
  text-overflow: ellipsis;
  white-space: nowrap;
}

.movie-meta {
  margin-bottom: 8px;
}

.movie-details {
  display: flex;
  gap: 12px;
  font-size: 13px;
  color: #666;
  margin-bottom: 8px;
}

.movie-quote {
  font-size: 13px;
  color: #666;
  font-style: italic;
  margin: 8px 0 0 0;
  overflow: hidden;
  text-overflow: ellipsis;
  display: -webkit-box;
  -webkit-line-clamp: 2;
  -webkit-box-orient: vertical;
}

.movie-actions {
  display: flex;
  gap: 8px;
  padding-top: 12px;
  border-top: 1px solid #f0f0f0;
}

.pagination {
  display: flex;
  justify-content: center;
  margin-top: 24px;
}
</style>
--------------------  END  --------------------


FILE_PATH: frontend\src\views\OCRTool.vue
-------------------- START --------------------
<template>
  <div class="ocr-container">
    <el-card>
      <template #header>
        <div class="card-header">
          <h2>图片文字识别 (OCR)</h2>
          <el-tag type="success">支持中英文识别</el-tag>
        </div>
      </template>

      <el-alert
        title="使用说明"
        type="info"
        :closable="false"
        style="margin-bottom: 24px;"
      >
        <p>1. 点击下方上传按钮选择图片文件</p>
        <p>2. 支持 JPG、PNG、GIF 等常见图片格式</p>
        <p>3. 为获得最佳识别效果，请上传清晰的图片</p>
        <p>4. 系统支持中文和英文文字识别</p>
      </el-alert>

      <el-row :gutter="20">
        <el-col :span="12">
          <el-card shadow="never" class="upload-card">
            <template #header>
              <h3>上传图片</h3>
            </template>
            
            <el-upload
              ref="uploadRef"
              class="upload-area"
              drag
              :auto-upload="false"
              :on-change="handleFileChange"
              :limit="1"
              :file-list="fileList"
              accept="image/*"
            >
              <el-icon class="el-icon--upload"><Upload /></el-icon>
              <div class="el-upload__text">
                将图片拖到此处，或<em>点击上传</em>
              </div>
              <template #tip>
                <div class="el-upload__tip">
                  支持 jpg/png/gif 文件，且不超过 10MB
                </div>
              </template>
            </el-upload>

            <div v-if="imagePreview" class="image-preview">
              <el-divider>图片预览</el-divider>
              <img :src="imagePreview" alt="预览图片" />
            </div>

            <el-button 
              type="primary" 
              size="large"
              style="width: 100%; margin-top: 16px;"
              :loading="recognizing"
              :disabled="!selectedFile"
              @click="recognizeImage"
            >
              <el-icon v-if="!recognizing"><MagicStick /></el-icon>
              {{ recognizing ? '识别中...' : '开始识别' }}
            </el-button>
          </el-card>
        </el-col>

        <el-col :span="12">
          <el-card shadow="never" class="result-card">
            <template #header>
              <div style="display: flex; justify-content: space-between; align-items: center;">
                <h3>识别结果</h3>
                <el-button 
                  v-if="recognizedText" 
                  size="small" 
                  @click="copyText"
                >
                  <el-icon><CopyDocument /></el-icon>
                  复制文本
                </el-button>
              </div>
            </template>

            <div v-if="!recognizedText && !recognizing" class="empty-result">
              <el-empty description="暂无识别结果，请上传图片并开始识别" />
            </div>

            <div v-if="recognizing" class="recognizing-status">
              <el-icon class="is-loading" :size="40"><Loading /></el-icon>
              <p style="margin-top: 16px; color: #666;">正在识别图片中的文字...</p>
              <el-progress 
                :percentage="recognitionProgress" 
                :indeterminate="true"
                style="margin-top: 12px;"
              />
            </div>

            <div v-if="recognizedText && !recognizing" class="result-text">
              <el-input
                v-model="recognizedText"
                type="textarea"
                :rows="15"
                placeholder="识别结果将显示在这里"
              />
              
              <div class="result-stats">
                <el-divider />
                <el-row :gutter="20">
                  <el-col :span="8">
                    <el-statistic title="字符数" :value="recognizedText.length" />
                  </el-col>
                  <el-col :span="8">
                    <el-statistic title="行数" :value="recognizedText.split('\n').length" />
                  </el-col>
                  <el-col :span="8">
                    <el-statistic title="单词数" :value="countWords(recognizedText)" />
                  </el-col>
                </el-row>
              </div>
            </div>
          </el-card>
        </el-col>
      </el-row>
    </el-card>

    <!-- 历史记录 -->
    <el-card v-if="history.length > 0" style="margin-top: 24px;">
      <template #header>
        <div style="display: flex; justify-content: space-between; align-items: center;">
          <h3>识别历史</h3>
          <el-button size="small" type="danger" @click="clearHistory">
            <el-icon><Delete /></el-icon>
            清空历史
          </el-button>
        </div>
      </template>

      <el-timeline>
        <el-timeline-item
          v-for="(item, index) in history"
          :key="index"
          :timestamp="item.timestamp"
          placement="top"
        >
          <el-card>
            <div class="history-item">
              <img :src="item.imageUrl" alt="历史图片" class="history-image" />
              <div class="history-text">
                <p>{{ truncateText(item.text, 100) }}</p>
                <el-button 
                  size="small" 
                  text 
                  @click="viewHistoryItem(item)"
                >
                  查看完整内容
                </el-button>
              </div>
            </div>
          </el-card>
        </el-timeline-item>
      </el-timeline>
    </el-card>

    <!-- 查看历史详情对话框 -->
    <el-dialog
      v-model="showHistoryDialog"
      title="识别详情"
      width="60%"
    >
      <div v-if="currentHistoryItem">
        <el-row :gutter="20">
          <el-col :span="12">
            <img :src="currentHistoryItem.imageUrl" style="width: 100%;" />
          </el-col>
          <el-col :span="12">
            <el-input
              :model-value="currentHistoryItem.text"
              type="textarea"
              :rows="15"
              readonly
            />
          </el-col>
        </el-row>
      </div>
      <template #footer>
        <el-button @click="showHistoryDialog = false">关闭</el-button>
        <el-button type="primary" @click="copyHistoryText">复制文本</el-button>
      </template>
    </el-dialog>
  </div>
</template>

<script setup lang="ts">
import { ref } from 'vue';
import { ElMessage } from 'element-plus';
import { ocrAPI } from '../api';

interface HistoryItem {
  imageUrl: string;
  text: string;
  timestamp: string;
}

const uploadRef = ref();
const fileList = ref<any[]>([]);
const selectedFile = ref<File | null>(null);
const imagePreview = ref('');
const recognizing = ref(false);
const recognitionProgress = ref(0);
const recognizedText = ref('');
const history = ref<HistoryItem[]>([]);
const showHistoryDialog = ref(false);
const currentHistoryItem = ref<HistoryItem | null>(null);

// 处理文件选择
const handleFileChange = (file: any) => {
  selectedFile.value = file.raw;
  fileList.value = [file];
  
  // 生成预览
  const reader = new FileReader();
  reader.onload = (e) => {
    imagePreview.value = e.target?.result as string;
  };
  reader.readAsDataURL(file.raw);
};

// 识别图片
const recognizeImage = async () => {
  if (!selectedFile.value) {
    ElMessage.warning('请先选择图片');
    return;
  }

  recognizing.value = true;
  recognitionProgress.value = 0;

  // 模拟进度
  const progressInterval = setInterval(() => {
    if (recognitionProgress.value < 90) {
      recognitionProgress.value += 10;
    }
  }, 300);

  try {
    const { data } = await ocrAPI.recognize(selectedFile.value);
    
    clearInterval(progressInterval);
    recognitionProgress.value = 100;
    
    recognizedText.value = data.text || '未识别到文字内容';
    
    // 添加到历史记录
    if (data.text) {
      history.value.unshift({
        imageUrl: imagePreview.value,
        text: data.text,
        timestamp: new Date().toLocaleString()
      });
      
      // 限制历史记录数量
      if (history.value.length > 10) {
        history.value = history.value.slice(0, 10);
      }
    }
    
    ElMessage.success('识别完成');
  } catch (error: any) {
    clearInterval(progressInterval);
    ElMessage.error(error.response?.data?.message || '识别失败，请重试');
    recognizedText.value = '';
  } finally {
    recognizing.value = false;
    recognitionProgress.value = 0;
  }
};

// 复制文本
const copyText = async () => {
  try {
    await navigator.clipboard.writeText(recognizedText.value);
    ElMessage.success('已复制到剪贴板');
  } catch (error) {
    ElMessage.error('复制失败');
  }
};

// 复制历史文本
const copyHistoryText = async () => {
  if (!currentHistoryItem.value) return;
  
  try {
    await navigator.clipboard.writeText(currentHistoryItem.value.text);
    ElMessage.success('已复制到剪贴板');
  } catch (error) {
    ElMessage.error('复制失败');
  }
};

// 统计单词数
const countWords = (text: string) => {
  const words = text.trim().split(/\s+/);
  return words.filter(word => word.length > 0).length;
};

// 截断文本
const truncateText = (text: string, maxLength: number) => {
  if (text.length <= maxLength) return text;
  return text.substring(0, maxLength) + '...';
};

// 查看历史项
const viewHistoryItem = (item: HistoryItem) => {
  currentHistoryItem.value = item;
  showHistoryDialog.value = true;
};

// 清空历史
const clearHistory = () => {
  history.value = [];
  ElMessage.success('历史记录已清空');
};
</script>

<style scoped>
.ocr-container {
  max-width: 1400px;
  margin: 0 auto;
}

.card-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
}

.card-header h2 {
  margin: 0;
  font-size: 24px;
  font-weight: 600;
}

.upload-card,
.result-card {
  min-height: 500px;
}

.upload-card h3,
.result-card h3 {
  margin: 0;
  font-size: 18px;
  font-weight: 600;
}

.upload-area {
  width: 100%;
}

.upload-area :deep(.el-upload-dragger) {
  width: 100%;
  height: 200px;
  display: flex;
  flex-direction: column;
  justify-content: center;
  align-items: center;
}

.el-icon--upload {
  font-size: 67px;
  color: #409eff;
  margin-bottom: 16px;
}

.image-preview {
  margin-top: 24px;
}

.image-preview img {
  width: 100%;
  max-height: 300px;
  object-fit: contain;
  border-radius: 8px;
  border: 1px solid #dcdfe6;
}

.empty-result {
  display: flex;
  justify-content: center;
  align-items: center;
  min-height: 400px;
}

.recognizing-status {
  display: flex;
  flex-direction: column;
  justify-content: center;
  align-items: center;
  min-height: 400px;
  padding: 40px;
}

.result-text {
  animation: fadeIn 0.5s;
}

@keyframes fadeIn {
  from {
    opacity: 0;
    transform: translateY(10px);
  }
  to {
    opacity: 1;
    transform: translateY(0);
  }
}

.result-stats {
  margin-top: 20px;
}

.history-item {
  display: flex;
  gap: 16px;
}

.history-image {
  width: 120px;
  height: 80px;
  object-fit: cover;
  border-radius: 4px;
  flex-shrink: 0;
}

.history-text {
  flex: 1;
}

.history-text p {
  margin: 0 0 8px 0;
  color: #666;
  line-height: 1.6;
}
</style>
--------------------  END  --------------------


FILE_PATH: frontend\src\views\Recommendations.vue
-------------------- START --------------------
<template>
  <div class="recommendations-container">
    <el-card>
      <template #header>
        <div class="card-header">
          <h2>电影推荐</h2>
          <el-button type="primary" @click="refreshRecommendations">
            <el-icon><Refresh /></el-icon>
            刷新推荐
          </el-button>
        </div>
      </template>

      <el-alert
        v-if="recommendations.length === 0 && !loading"
        title="暂无推荐"
        type="info"
        :closable="false"
        style="margin-bottom: 20px;"
      >
        <p>系统根据您的收藏为您推荐电影</p>
        <p>快去收藏一些电影吧！收藏越多，推荐越精准</p>
      </el-alert>

      <!-- 推荐说明 -->
      <el-card v-if="favoriteStats" shadow="never" style="margin-bottom: 24px;">
        <template #header>
          <h3>推荐依据</h3>
        </template>
        <el-descriptions :column="3" border>
          <el-descriptions-item label="已收藏电影">
            {{ favoriteStats.totalFavorites }} 部
          </el-descriptions-item>
          <el-descriptions-item label="最喜欢的类型">
            <el-tag v-for="genre in favoriteStats.topGenres" :key="genre" style="margin-right: 5px;">
              {{ genre }}
            </el-tag>
          </el-descriptions-item>
          <el-descriptions-item label="平均评分偏好">
            {{ favoriteStats.avgRating?.toFixed(1) || 0 }} 分
          </el-descriptions-item>
        </el-descriptions>
      </el-card>

      <div v-loading="loading" class="recommendations-grid">
        <el-card 
          v-for="movie in recommendations" 
          :key="movie._id" 
          class="movie-card"
          shadow="hover"
        >
          <div class="movie-cover" @click="viewDetail(movie._id)">
            <img :src="getImageUrl(movie)" :alt="movie.title" />
            <div class="rank-badge">TOP {{ movie.rank }}</div>
            <div class="match-badge">
              <el-icon><MagicStick /></el-icon>
              推荐
            </div>
            <div class="overlay">
              <el-button type="primary" circle size="large">
                <el-icon><View /></el-icon>
              </el-button>
            </div>
          </div>
          
          <div class="movie-info">
            <h3 class="movie-title" @click="viewDetail(movie._id)">
              {{ movie.title }}
            </h3>
            <p class="movie-original-title">{{ movie.originalTitle }}</p>
            
            <div class="movie-meta">
              <el-rate 
                v-model="movie.rating" 
                disabled 
                show-score 
                text-color="#ff9900" 
                :max="10"
              />
            </div>
            
            <div class="movie-details">
              <el-tag size="small" type="info">{{ movie.year }}</el-tag>
              <el-tag 
                v-for="genre in movie.genres.slice(0, 3)" 
                :key="genre" 
                size="small"
                style="margin-left: 5px;"
                :type="isMatchingGenre(genre) ? 'success' : ''"
              >
                {{ genre }}
              </el-tag>
            </div>
            
            <p v-if="movie.quote" class="movie-quote">"{{ movie.quote }}"</p>
            
            <div class="movie-directors">
              <el-icon><User /></el-icon>
              <span>{{ movie.directors.join(', ') }}</span>
            </div>
            
            <div class="match-reasons">
              <el-divider content-position="left">
                <el-text size="small" type="info">推荐理由</el-text>
              </el-divider>
              <el-space wrap>
                <el-tag 
                  v-for="reason in getMatchReasons(movie)" 
                  :key="reason"
                  size="small"
                  type="success"
                  effect="plain"
                >
                  {{ reason }}
                </el-tag>
              </el-space>
            </div>
          </div>
          
          <div class="movie-actions">
            <el-button 
              size="small" 
              type="primary" 
              @click="viewDetail(movie._id)"
            >
              <el-icon><View /></el-icon>
              查看详情
            </el-button>
            <el-button 
              size="small" 
              :type="isFavorited(movie._id) ? 'danger' : 'success'"
              @click="toggleFavorite(movie._id)"
            >
              <el-icon><Star /></el-icon>
              {{ isFavorited(movie._id) ? '取消收藏' : '收藏' }}
            </el-button>
          </div>
        </el-card>
      </div>

      <el-empty 
        v-if="recommendations.length === 0 && !loading" 
        description="暂无推荐，快去收藏电影吧"
        style="padding: 60px 0;"
      />
    </el-card>

    <!-- 推荐算法说明 -->
    <el-card style="margin-top: 24px;">
      <template #header>
        <h3>推荐算法说明</h3>
      </template>
      
      <el-timeline>
        <el-timeline-item timestamp="步骤 1" placement="top">
          <el-card>
            <h4>分析收藏偏好</h4>
            <p>系统会分析您收藏的电影类型、评分、年代等特征，建立您的观影偏好模型</p>
          </el-card>
        </el-timeline-item>
        
        <el-timeline-item timestamp="步骤 2" placement="top">
          <el-card>
            <h4>类型匹配</h4>
            <p>根据您最喜欢的电影类型，从数据库中筛选相同或相似类型的电影</p>
          </el-card>
        </el-timeline-item>
        
        <el-timeline-item timestamp="步骤 3" placement="top">
          <el-card>
            <h4>质量筛选</h4>
            <p>优先推荐高评分（8分以上）且评价人数较多的优质电影</p>
          </el-card>
        </el-timeline-item>
        
        <el-timeline-item timestamp="步骤 4" placement="top">
          <el-card>
            <h4>排除已收藏</h4>
            <p>自动过滤您已经收藏的电影，确保推荐内容都是新发现</p>
          </el-card>
        </el-timeline-item>
      </el-timeline>
    </el-card>
  </div>
</template>

<script setup lang="ts">
import { ref, onMounted, computed } from 'vue';
import { useRouter } from 'vue-router';
import { ElMessage } from 'element-plus';
import { recommendationAPI, favoriteAPI } from '../api';
import type { Movie } from '../types';

const router = useRouter();
const loading = ref(false);
const recommendations = ref<Movie[]>([]);
const favoritedIds = ref<Set<string>>(new Set());
const favoriteStats = ref<{
  totalFavorites: number;
  topGenres: string[];
  avgRating: number;
} | null>(null);

// 获取推荐
const fetchRecommendations = async () => {
  loading.value = true;
  try {
    const { data } = await recommendationAPI.get();
    recommendations.value = data;
    
    // 计算收藏统计
    await calculateFavoriteStats();
  } catch (error: any) {
    ElMessage.error(error.response?.data?.message || '获取推荐失败');
  } finally {
    loading.value = false;
  }
};

// 计算收藏统计
const calculateFavoriteStats = async () => {
  try {
    const { data: favorites } = await favoriteAPI.getList();
    
    // 统计类型
    const genreCount: Record<string, number> = {};
    favorites.forEach((movie: Movie) => {
      movie.genres.forEach(genre => {
        genreCount[genre] = (genreCount[genre] || 0) + 1;
      });
    });
    
    // 获取前3个最喜欢的类型
    const topGenres = Object.entries(genreCount)
      .sort((a, b) => b[1] - a[1])
      .slice(0, 3)
      .map(([genre]) => genre);
    
    // 计算平均评分
    const avgRating = favorites.length > 0
      ? favorites.reduce((sum: number, m: Movie) => sum + m.rating, 0) / favorites.length
      : 0;
    
    favoriteStats.value = {
      totalFavorites: favorites.length,
      topGenres,
      avgRating
    };
    
    // 保存已收藏的ID
    favoritedIds.value = new Set(favorites.map((m: Movie) => m._id));
  } catch (error) {
    console.error('计算收藏统计失败', error);
  }
};

// 刷新推荐
const refreshRecommendations = () => {
  fetchRecommendations();
  ElMessage.success('正在为您刷新推荐...');
};

// 查看详情
const viewDetail = (id: string) => {
  router.push(`/movies/${id}`);
};

// 获取图片URL
const getImageUrl = (movie: Movie) => {
  if (movie.localCoverPath) {
    let path = movie.localCoverPath;
    
    if (path.startsWith('./images/')) {
      path = path.replace('./', '/');
    } else if (path.startsWith('./uploads/')) {
      path = path.replace('./', '/');
    }
    
    if (path.startsWith('http://') || path.startsWith('https://')) {
      return path;
    }
    
    return path;
  }
  
  return movie.coverImageUrl || '/placeholder.png';
};

// 判断是否是匹配的类型
const isMatchingGenre = (genre: string) => {
  return favoriteStats.value?.topGenres.includes(genre) || false;
};

// 获取推荐理由
const getMatchReasons = (movie: Movie) => {
  const reasons: string[] = [];
  
  // 类型匹配
  const matchingGenres = movie.genres.filter(g => 
    favoriteStats.value?.topGenres.includes(g)
  );
  if (matchingGenres.length > 0) {
    reasons.push(`类型匹配: ${matchingGenres.join('、')}`);
  }
  
  // 高评分
  if (movie.rating >= 9.0) {
    reasons.push('高分佳作');
  } else if (movie.rating >= 8.5) {
    reasons.push('评分优秀');
  }
  
  // 热门
  if (movie.ratingCount > 500000) {
    reasons.push('口碑热门');
  }
  
  // 经典
  if (movie.year < 2000) {
    reasons.push('经典作品');
  } else if (movie.year > 2015) {
    reasons.push('近年佳作');
  }
  
  return reasons.length > 0 ? reasons : ['为您推荐'];
};

// 判断是否已收藏
const isFavorited = (movieId: string) => {
  return favoritedIds.value.has(movieId);
};

// 切换收藏状态
const toggleFavorite = async (movieId: string) => {
  try {
    if (isFavorited(movieId)) {
      await favoriteAPI.remove(movieId);
      favoritedIds.value.delete(movieId);
      ElMessage.success('已取消收藏');
    } else {
      await favoriteAPI.add(movieId);
      favoritedIds.value.add(movieId);
      ElMessage.success('收藏成功');
    }
  } catch (error: any) {
    ElMessage.error(error.response?.data?.message || '操作失败');
  }
};

onMounted(() => {
  fetchRecommendations();
});
</script>

<style scoped>
.recommendations-container {
  max-width: 1400px;
  margin: 0 auto;
}

.card-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
}

.card-header h2 {
  margin: 0;
  font-size: 24px;
  font-weight: 600;
}

.recommendations-grid {
  display: grid;
  grid-template-columns: repeat(auto-fill, minmax(300px, 1fr));
  gap: 24px;
  min-height: 200px;
}

.movie-card {
  transition: all 0.3s;
}

.movie-card:hover {
  transform: translateY(-8px);
  box-shadow: 0 8px 24px rgba(0, 0, 0, 0.15);
}

.movie-cover {
  position: relative;
  width: 100%;
  height: 400px;
  overflow: hidden;
  border-radius: 8px;
  cursor: pointer;
}

.movie-cover img {
  width: 100%;
  height: 100%;
  object-fit: cover;
  transition: transform 0.3s;
}

.movie-cover:hover img {
  transform: scale(1.1);
}

.rank-badge {
  position: absolute;
  top: 12px;
  left: 12px;
  background: rgba(255, 152, 0, 0.95);
  color: white;
  font-weight: bold;
  padding: 6px 12px;
  border-radius: 20px;
  font-size: 14px;
  box-shadow: 0 2px 8px rgba(0, 0, 0, 0.2);
}

.match-badge {
  position: absolute;
  top: 12px;
  right: 12px;
  background: rgba(103, 194, 58, 0.95);
  color: white;
  font-weight: bold;
  padding: 6px 12px;
  border-radius: 20px;
  font-size: 14px;
  box-shadow: 0 2px 8px rgba(0, 0, 0, 0.2);
  display: flex;
  align-items: center;
  gap: 4px;
}

.overlay {
  position: absolute;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  background: rgba(0, 0, 0, 0.6);
  display: flex;
  justify-content: center;
  align-items: center;
  opacity: 0;
  transition: opacity 0.3s;
}

.movie-cover:hover .overlay {
  opacity: 1;
}

.movie-info {
  padding: 16px 0;
}

.movie-title {
  font-size: 18px;
  font-weight: 600;
  margin: 0 0 6px 0;
  color: #333;
  overflow: hidden;
  text-overflow: ellipsis;
  white-space: nowrap;
  cursor: pointer;
  transition: color 0.3s;
}

.movie-title:hover {
  color: #409eff;
}

.movie-original-title {
  font-size: 14px;
  color: #999;
  margin: 0 0 12px 0;
  overflow: hidden;
  text-overflow: ellipsis;
  white-space: nowrap;
}

.movie-meta {
  margin-bottom: 12px;
}

.movie-details {
  display: flex;
  flex-wrap: wrap;
  gap: 6px;
  margin-bottom: 12px;
}

.movie-quote {
  font-size: 13px;
  color: #666;
  font-style: italic;
  margin: 8px 0;
  overflow: hidden;
  text-overflow: ellipsis;
  display: -webkit-box;
  -webkit-line-clamp: 2;
  -webkit-box-orient: vertical;
}

.movie-directors {
  display: flex;
  align-items: center;
  gap: 6px;
  font-size: 13px;
  color: #666;
  margin-bottom: 12px;
}

.match-reasons {
  margin-top: 16px;
}

.movie-actions {
  display: flex;
  gap: 8px;
  padding-top: 16px;
  border-top: 1px solid #f0f0f0;
}

.movie-actions .el-button {
  flex: 1;
}
</style>
--------------------  END  --------------------


FILE_PATH: frontend\src\views\Register.vue
-------------------- START --------------------
<template>
  <div class="register-container">
    <div class="register-box">
      <h1 class="title">创建账户</h1>
      <p class="subtitle">加入电影管理系统</p>
      
      <el-form :model="form" :rules="rules" ref="formRef" class="register-form">
        <el-form-item prop="username">
          <el-input
            v-model="form.username"
            placeholder="用户名"
            prefix-icon="User"
            size="large"
          />
        </el-form-item>
        
        <el-form-item prop="email">
          <el-input
            v-model="form.email"
            placeholder="邮箱（可选）"
            prefix-icon="Message"
            size="large"
          />
        </el-form-item>
        
        <el-form-item prop="password">
          <el-input
            v-model="form.password"
            type="password"
            placeholder="密码"
            prefix-icon="Lock"
            size="large"
            show-password
          />
        </el-form-item>
        
        <el-form-item prop="confirmPassword">
          <el-input
            v-model="form.confirmPassword"
            type="password"
            placeholder="确认密码"
            prefix-icon="Lock"
            size="large"
            show-password
            @keyup.enter="handleRegister"
          />
        </el-form-item>
        
        <el-form-item>
          <el-button
            type="primary"
            size="large"
            style="width: 100%"
            :loading="loading"
            @click="handleRegister"
          >
            注册
          </el-button>
        </el-form-item>
      </el-form>
      
      <div class="login-link">
        已有账户？
        <router-link to="/login">立即登录</router-link>
      </div>
    </div>
  </div>
</template>

<script setup lang="ts">
import { reactive, ref } from 'vue';
import { useRouter } from 'vue-router';
import { ElMessage, type FormInstance, type FormRules } from 'element-plus';
import { authAPI } from '../api';

const router = useRouter();
const formRef = ref<FormInstance>();
const loading = ref(false);

const form = reactive({
  username: '',
  email: '',
  password: '',
  confirmPassword: ''
});

const validatePass2 = (rule: any, value: any, callback: any) => {
  if (value === '') {
    callback(new Error('请再次输入密码'));
  } else if (value !== form.password) {
    callback(new Error('两次输入密码不一致'));
  } else {
    callback();
  }
};

const rules: FormRules = {
  username: [
    { required: true, message: '请输入用户名', trigger: 'blur' },
    { min: 3, message: '用户名至少3个字符', trigger: 'blur' }
  ],
  password: [
    { required: true, message: '请输入密码', trigger: 'blur' },
    { min: 6, message: '密码至少6个字符', trigger: 'blur' }
  ],
  confirmPassword: [
    { required: true, validator: validatePass2, trigger: 'blur' }
  ]
};

const handleRegister = async () => {
  if (!formRef.value) return;
  
  await formRef.value.validate(async (valid) => {
    if (!valid) return;
    
    loading.value = true;
    try {
      await authAPI.register({
        username: form.username,
        password: form.password,
        email: form.email || undefined
      });
      
      ElMessage.success('注册成功！请登录');
      router.push('/login');
    } catch (error: any) {
      ElMessage.error(error.response?.data?.message || '注册失败');
    } finally {
      loading.value = false;
    }
  });
};
</script>

<style scoped>
.register-container {
  display: flex;
  justify-content: center;
  align-items: center;
  min-height: 100vh;
  background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
  padding: 20px;
}

.register-box {
  width: 100%;
  max-width: 400px;
  background: white;
  padding: 40px;
  border-radius: 12px;
  box-shadow: 0 10px 40px rgba(0, 0, 0, 0.1);
}

.title {
  font-size: 28px;
  font-weight: 700;
  color: #333;
  text-align: center;
  margin-bottom: 8px;
}

.subtitle {
  font-size: 14px;
  color: #666;
  text-align: center;
  margin-bottom: 30px;
}

.register-form {
  margin-top: 24px;
}

.login-link {
  text-align: center;
  margin-top: 20px;
  font-size: 14px;
  color: #666;
}

.login-link a {
  color: #667eea;
  text-decoration: none;
  font-weight: 500;
}

.login-link a:hover {
  text-decoration: underline;
}
</style>
--------------------  END  --------------------


FILE_PATH: frontend\src\views\Statistics.vue
-------------------- START --------------------
<template>
  <div class="statistics">
    <el-row :gutter="20">
      <el-col :span="8">
        <el-card>
          <el-statistic title="电影总数" :value="stats.totalMovies" />
        </el-card>
      </el-col>
      <el-col :span="8">
        <el-card>
          <el-statistic title="平均评分" :value="stats.avgRating" :precision="2" />
        </el-card>
      </el-col>
      <el-col :span="8">
        <el-card>
          <el-statistic title="类型数量" :value="stats.topGenres?.length || 0" />
        </el-card>
      </el-col>
    </el-row>
    
    <el-row :gutter="20" style="margin-top: 20px;">
      <el-col :span="12">
        <el-card>
          <template #header><h3>评分分布</h3></template>
          <div ref="ratingChart" style="height: 400px;"></div>
        </el-card>
      </el-col>
      <el-col :span="12">
        <el-card>
          <template #header><h3>年份分布</h3></template>
          <div ref="yearChart" style="height: 400px;"></div>
        </el-card>
      </el-col>
    </el-row>
  </div>
</template>

<script setup lang="ts">
import { ref, onMounted, nextTick } from 'vue';
import * as echarts from 'echarts';
import { statsAPI } from '../api';
import { ElMessage } from 'element-plus';

const stats = ref<any>({});
const ratingChart = ref();
const yearChart = ref();

const fetchStats = async () => {
  try {
    const { data } = await statsAPI.getOverview();
    stats.value = data;
  } catch (error) {
    ElMessage.error('获取统计数据失败');
  }
};

const initCharts = async () => {
  await nextTick();
  
  try {
    const { data: ratingData } = await statsAPI.getRatingDistribution();
    const ratingChartInstance = echarts.init(ratingChart.value);
    
    const labels = ratingData.map((item: any) => item.label);
    const counts = ratingData.map((item: any) => item.count);
    
    ratingChartInstance.setOption({
      tooltip: { 
        trigger: 'axis',
        axisPointer: {
          type: 'shadow'
        },
        formatter: (params: any) => {
          const param = params[0];
          return `${param.name}<br/>电影数量: ${param.value}`;
        }
      },
      grid: {
        left: '3%',
        right: '4%',
        bottom: '3%',
        containLabel: true
      },
      xAxis: { 
        type: 'category', 
        data: labels,
        name: '评分区间',
        axisLabel: {
          interval: 0,
          rotate: 0
        }
      },
      yAxis: { 
        type: 'value',
        name: '电影数量'
      },
      series: [{ 
        data: counts, 
        type: 'bar', 
        itemStyle: { 
          color: '#5470c6',
          borderRadius: [4, 4, 0, 0]
        },
        label: {
          show: true,
          position: 'top',
          formatter: '{c}'
        },
        barWidth: '60%'
      }]
    });
  } catch (error) {
    ElMessage.error('加载评分分布图表失败');
    console.error('Rating chart error:', error);
  }
  
  try {
    const { data: yearData } = await statsAPI.getYearDistribution();
    const yearChartInstance = echarts.init(yearChart.value);
    
    const years = yearData.map((d: any) => d._id).sort((a: number, b: number) => a - b);
    const counts = years.map((y: number) => yearData.find((d: any) => d._id === y)?.count || 0);
    
    yearChartInstance.setOption({
      tooltip: { 
        trigger: 'axis',
        axisPointer: {
          type: 'cross'
        },
        formatter: (params: any) => {
          const param = params[0];
          return `${param.name}年<br/>电影数量: ${param.value}`;
        }
      },
      grid: {
        left: '3%',
        right: '4%',
        bottom: '3%',
        containLabel: true
      },
      xAxis: { 
        type: 'category', 
        data: years,
        name: '年份',
        boundaryGap: false
      },
      yAxis: { 
        type: 'value',
        name: '电影数量'
      },
      series: [{ 
        data: counts, 
        type: 'line', 
        smooth: true, 
        itemStyle: { color: '#91cc75' },
        areaStyle: {
          color: 'rgba(145, 204, 117, 0.3)'
        },
        lineStyle: {
          width: 3
        }
      }]
    });
  } catch (error) {
    ElMessage.error('加载年份分布图表失败');
    console.error('Year chart error:', error);
  }
};

onMounted(() => {
  fetchStats();
  initCharts();
});
</script>

<style scoped>
.statistics { 
  max-width: 1400px; 
  margin: 0 auto; 
}
</style>
--------------------  END  --------------------


